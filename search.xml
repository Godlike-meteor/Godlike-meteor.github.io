<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[如何在 Visual Studio Code 中优雅的写 MySQL]]></title>
    <url>%2F2018%2F10%2F13%2F%E5%A6%82%E4%BD%95%E5%9C%A8-Visual-Studio-Code-%E4%B8%AD%E4%BC%98%E9%9B%85%E7%9A%84%E5%86%99-MySQL%2F</url>
    <content type="text"><![CDATA[相信大家都对数据库有很多的理解，以前笔者经常用 Navicat Premiun 12 进行数据库的编写，但是无奈样式和方法还有所不同，使用起来并不是很方便，所以笔者突发奇想有没有使用 Visual Studio Code 编译MySQL数据库的能力呢？（Visual Studio Code 天下第一！）这不，笔者就带来这篇教程带你配置和在 Visual Studio Code 上运行MySQL数据库 XAMPP由于笔者在之前使用WAMP进行过简单的项目设计，所以笔者数据库选择的是集成环境xampp，它具有某些配置设置，可以在本地轻松开发。可以在Xampp官方下载链接 进行下载，直接点击下一步即可，本教程主要使用到xampp打开数据库的操作，直接点击start即可，可以看到数据库占用端口3306 Visual Studio Code MYSQL 插件接下来就配置 Visual Studio Code 的环境，使用插件搜索功能，搜索插件 MySQL并进行下载并且重启。 利用 Visual Studio Code 插件运行数据库点击文件选项，注意最下方的MYSQL，点击“+”号进入MySQL配置 依次输入数据库主机名，用户名，密码后登陆到数据库中例: localhost [回车] root [回车] [回车] …. —- 用户名root 密码为空 在数据库中右击 点选 NEW QUERY 就可以写sql代码了， 运行数据库：右键 *.sql 文件，选择 Run MYSQL Query 运行，运行结果如下： 好了今天的分享就到这里，谢谢大家]]></content>
  </entry>
  <entry>
    <title><![CDATA[在 Visual Studio Code 中运行C#项目]]></title>
    <url>%2F2018%2F09%2F07%2F%E5%88%A9%E7%94%A8vscode%E7%BC%96%E5%86%99C-%E7%9A%84%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[在 Visual Studio Code 中运行C#项目前言.NET.NET是 Microsoft XML Web services 平台。XML Web services 允许应用程序通过 Internet 进行通讯和共享数据，而不管所采用的是哪种操作系统、设备或编程语言。Microsoft .NET 平台提供创建 XML Web services 并将这些服务集成在一起之所需。对个人用户的好处是无缝的、吸引人的体验。而C#语言则是.Net公司中的一个优秀的面向对象语言。我们可以用轻量级编译器 Visual Studio Code 进行 C# 代码的编译过程。 环境安装首先我们要进行VSCode的下载安装，傻瓜式安装直接点下一步即可，→VSCode官网下载 然后我们得配置一下.NET的运行环境，安装.NET Core SDK 然后在我们的VSCode中下载C#插件，下载完重启VScode窗口即可生效。 新建项目在VSCode终端输入cd:你创建的项目文件目录 12//例如cd D:\C# 然后输入: dotnet new -help ,会出现创建新项目命令的提示信息 1dotnet new --help 然后创建一个简单的控制台应用程序即为C#项目程序 1dotnet new console 在控制台运行创建的控制台程序 1dotnet run 最后用VScode打开我们刚才创建的项目目录，软件会自动下载.NET Core Debugger，等待下载安装（安装调式插件）。现在就可以在VScode中运行或者调试C#项目了，新建项目后Program.cs即为C#的源文件。 项目运行命令：dotnet run]]></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:旋转数组]]></title>
    <url>%2F2018%2F07%2F10%2FLeetCode-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[旋转数组给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 示例1: 输入: [1,2,3,4,5,6,7] 和 k = 3输出: [5,6,7,1,2,3,4]解释:向右旋转 1 步: [7,1,2,3,4,5,6]向右旋转 2 步: [6,7,1,2,3,4,5]向右旋转 3 步: [5,6,7,1,2,3,4] 示例2: 输入: [-1,-100,3,99] 和 k = 2输出: [3,99,-1,-100]解释:向右旋转 1 步: [99,-1,-100,3]向右旋转 2 步: [3,99,-1,-100] 说明:尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。要求使用空间复杂度为 O(1) 的原地算法。 解题思路利用原生JavaScript的简单的数组操作，循环进行入栈出栈操作即可。 代码12345678910/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; k * @return &#123;void&#125; Do not return anything, modify nums in-place instead. */var rotate = function(nums, k) &#123; while(k--)&#123; nums.unshift(nums.pop()); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:买卖股票的最佳时机]]></title>
    <url>%2F2018%2F07%2F05%2FLeetCCode-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[买卖股票的最佳时机 II给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例1: 输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例2: 输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例2: 输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 解题思路我们可以发现，这是一道典型的动态规划题，但是由于是基础，所以我们可以用数组进行简单的工作，我们只需要寻找前一天比今天的价值高就买入，后一天比今天价值低就卖出，即可解决该题。 代码123456789101112131415161718/** * @param &#123;number[]&#125; prices * @return &#123;number&#125; */var maxProfit = function(prices) &#123; var minPrice = prices[0]; var sumProfit = 0; for(let i=1;i&lt;prices.length;i++)&#123; if(minPrice&lt;prices[i])&#123; sumProfit += prices[i] - minPrice; minPrice = prices[i]; &#125; else&#123; minPrice = prices[i]; &#125; &#125; return sumProfit;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode:从排序数组中删除重复项]]></title>
    <url>%2F2018%2F07%2F04%2FLeetCode-%E4%BB%8E%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[从排序数组中删除重复项给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。 示例1: 给定数组 nums = [1,1,2],函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。你不需要考虑数组中超出新长度后面的元素。 示例2: 给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。 说明:为什么返回数值是整数，但输出的答案是数组呢?请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。你可以想象内部操作如下:12345678// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123; print(nums[i]);&#125; 解题思路根据题目很好想出思路，首先从一开始定义一个标志位，每次找到不是重复的数字，标志位++，然后将标志位处的数字替换，最后返回数组的遍历长度。 代码12345678910111213141516/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var removeDuplicates = function(nums) &#123; var flog = 1; var number = nums[0]; for(let i=1;i&lt;nums.length;i++)&#123; if(nums[i]!=number)&#123; nums[flog] = nums[i]; flog++; number = nums[i]; &#125; &#125; return flog;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数值分析函数画图模版：拉格朗日插值]]></title>
    <url>%2F2018%2F03%2F29%2F%E6%95%B0%E5%80%BC%E5%88%86%E6%9E%90%E5%87%BD%E6%95%B0%E7%94%BB%E5%9B%BE%E6%A8%A1%E7%89%88%EF%BC%9A%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%2F</url>
    <content type="text"><![CDATA[新学期开了数值分析课，老师要求实验需要编写函数并使用MATLAB之类的工具画出函数图像，怎奈何MATLAB需要花费很多的前并且不是很好用，canvas画图太过于繁琐，所以就开发了一种js暴力画图方法，来完成整个课程的设计。 思路探讨画图无非就是将一个个的小圆点尽可能的小并且尽可能的密，在不考虑算法时间复杂度和性能的前提下，我尝试用函数创建大量的圆点并且通过position进行定位实现本次实验的效果，完成后的效果如下（点稍微有点大导致锯齿化严重，后续可优化） 拉格朗日插值法12345678910111213141516171819var x = [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 110, 120];var y = [5, 1, 7.5, 3, 4.5, 8.8, 15.5, 6.5, -5, -10, -2, 4.5, 7];function Lagrange(element) &#123; var Ln = 0.0; for (var k = 0; k &lt;= 12; k++) &#123; Ln += y[k] * L(k, element); &#125; return Ln; // console.log(Ln);&#125;function L(k, element) &#123; var Lx = 1; for (var j = 0; j &lt;= 12; j++) &#123; if (j != k) &#123; Lx = Lx * ((element - x[j]) / (x[k] - x[j])); &#125; &#125; return Lx;&#125; 暴力画图函数及代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!-- HTML --&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;数值分析实验&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; &#125; .box &#123; height: 500px; width: 800px; position: absolute; left: 50%; top: 50%; margin-top: -250px; margin-left: -400px; border-left: 2px solid #333; &#125; .circle &#123; width: 10px; height: 10px; background-color: #000; border-radius: 20px; position: absolute; &#125; .sign&#123; height: 2px; width: 800px; background-color: #333; position: absolute; top: 250px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot; id=&quot;main&quot;&gt; &lt;div class=&quot;sign&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;!-- 暴力画图算法 --&gt;function insert(x, y) &#123; console.log(y); var main = document.getElementById(&quot;main&quot;); var div = document.createElement(&quot;div&quot;); div.className = &quot;circle&quot;; div.style.top = (250 - y*5 + 5) + &quot;px&quot;; div.style.left = (x*5 - 5) + &quot;px&quot;; main.appendChild(div);&#125;function maine() &#123; for (var b=0; b &lt;= 120;) &#123; insert(b, Lagrange(b)); b+=0.01; &#125;&#125;maine();]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数值分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用JavaScript实现中缀表达式计算器【2.0】]]></title>
    <url>%2F2018%2F03%2F03%2F%E7%94%A8JavaScript%E5%AE%9E%E7%8E%B0%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E7%AE%97%E5%99%A8%E3%80%902-0%E3%80%91%2F</url>
    <content type="text"><![CDATA[上次跟大家说到有关JavaScript中缀计算器的有关代码，但是在优化的过程中发现了一些问题，经过老师的指导改进了一下代码，形成了更易于理解的语法规范和界面交互，就本次代码更新分享给大家。 改进一：提供更直观的计算按钮经过老师的建议，我添加了有关的计算的按钮，其实就是通过点击相应的按钮，获取显示框中的表达式并进行拆分，然后调用不同的计算函数来实现计算的结果。 1234567891011121314151617181920212223242526272829303132function getResultInfix()&#123; var txt = document.getElementById("txtScream"); var text = document.getElementById("textarea"); if(Judge(txt.value)==1)&#123; var transit = txt.value + '#'; text.value = "中缀计算的结果为："; //调用中缀计算函数 txt.value = Infix(transit); &#125;&#125;function getResultsuffix()&#123; var txt = document.getElementById("txtScream"); var text = document.getElementById("textarea"); if(Judge(txt.value)==1)&#123; var transit = txt.value + '#'; text.value = "后缀计算的结果为："; //调用后缀计算函数 txt.value = suffix(transit); &#125;&#125;function getResultChange()&#123; var txt = document.getElementById("txtScream"); var text = document.getElementById("textarea"); if(Judge(txt.value)==1)&#123; var transit = txt.value + '#'; text.value = "后缀表达式的结果为："; //调用中缀转后缀函数 txt.value = Change(transit); &#125;&#125; 改进二：括号匹配异常处理在上一个例子中是没有加入括号匹配异常处理的，在实际操作中我发现不添加异常处理的话会使程序发生运算bug，导致运算结果不准确，加入异常处理使遇到括号不匹配的问题时提示用户检查计算式是否正确，来矫正用户的输入错误。 123456789101112131415161718192021222324function Judge(item)&#123; var str=item; var outStack=new Stack(); outStack.push('#'); for(var i=0;i&lt;item.length;i++)&#123; if(str[i]=='(')&#123; outStack.push('('); &#125; else if(str[i]==')')&#123; if(outStack.peek()=='(')&#123; outStack.pop(); &#125; else&#123; alert("抱歉，您的括号不能够匹配，请检查你的输入！"); return 0; &#125; &#125; &#125; if(outStack.peek()!='#')&#123; alert("抱歉，您的括号不能够匹配，请检查你的输入！"); return 0; &#125; return 1;&#125; 即在判断函数即处理括号匹配问题，如果处理的不准确，立即停止操作，直到用户输入正确为止。 运算符按钮的优化在实际操作中，发现会有一些更容易发生的问题，例如用户没有输入数字直接输入运算符的话运算会导致运算结果不准确或者程序停止运行，再例如用户输入一个运算符后直接输入另外一个运算符，都会使程序产生问题，这就需要对运算符控制函数进行修改，具体代码如下： 1234567891011121314function putTheControlKey(control)&#123; var txt = document.getElementById("txtScream"); // 处理空输入提醒用户 if(txt.value == 0) &#123; alert("请先输入至少一个数字后再输入运算符！"); return; &#125; //如果输入框最后一个字符是运算符，先删除最后的运算符，再将键入运算符加入字符串尾 if(txt.value[txt.value.length-1] =="+" || txt.value[txt.value.length-1] =="-" || txt.value[txt.value.length-1] =="*" || txt.value[txt.value.length-1] =="/")&#123; backSpace(); &#125; txt.value += control.value;&#125; 其他优化诸如除零异常处理，后缀表达式逗号隔开，负数处理等都进行了优化，具体效果请查看神奇的计算器（改进版）,附上完成图，谢谢大家。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git技巧:本地项目网络化]]></title>
    <url>%2F2018%2F03%2F01%2FGit%E6%8A%80%E5%B7%A7-%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E7%BD%91%E7%BB%9C%E5%8C%96%2F</url>
    <content type="text"><![CDATA[这篇文章主要是就上篇文章Git技巧:本地项目上传Github项目的优化，大家也许会有如下的苦恼：本地网页建好无法在网络上查看，也无法在手机上查看，GitHub就提供给程序员一个非常棒的环境，我们不用搭建服务器就可以在网络上实现项目的共享和查看。 GitHub提供接口首先我们必须先登录GitHub和BitBucket HTML预览,就是如下图所示的一个转接口，同时我们想要在网络分享也需要这个接口。 预览的HTML文件的URL现在你只需要将预览的HTML文件的URL放入输入框中就可以预览你的项目了，就我的项目为例，我们需要进入整个项目的主页面也就是index.html中，复制地址栏的地址，也就是你的要预览的HTML文件的URL。 预览最后复制到input中就可以实现网络的预览和分享了，是不是很神奇呢？一起来试试吧！]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git技巧:本地项目上传Github]]></title>
    <url>%2F2018%2F03%2F01%2FGit%E7%9A%84%E4%BD%BF%E7%94%A8-%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E4%B8%8A%E4%BC%A0Github%2F</url>
    <content type="text"><![CDATA[最近做了很多新的项目，就很想将所得的项目传到GitHub上，今天就带来一篇简单的Git技巧，就是将本地的项目传送到GitHub上。 详细步骤此处略过Git安装步骤，具体安装步骤请百度。 第一步：创建本地库（新建文件夹）方法一直接右键新建名为project文件夹，右键Git bash命令行窗口通过以下命令进入即可。 1$ cd project 方法二右键Git bash命令行窗口通过命令来创建，使用下面的命令在任何地方创建一个名为project的文件夹，并进入这个文件夹。 12$ mkdir project$ cd project 第二步：将文件夹变成可管理的仓库在命令行输入以下命令： 1$ git init 你会发现project文件夹里面多了个.git文件夹，它是Git用来跟踪和管理本地仓库的，如果文件夹里没有.git文件夹，需要设置一下让隐藏文件可见。 第三步：把项目添加到本地库接下来就需要把项目的代码粘贴到本地Git仓库里面，然后通过git add把项目添加到仓库，这个过程可以用git status来查看当前的状态。 1$ git status 然后将刚才复制下来的项目全部添加到仓库里，用git add .命令来实现,然后查看一下当前状态。 12$ git add .$ git status 第四步：把项目提交到仓库用git commit把项目提交到仓库。 1$ git commit -m "first commit" 好了，本地仓库整完了，接下来就需要连接远程仓库。 第五步：创建SSH KEY由于本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，连接时要设置SSH KEY，先看一下C盘用户目录有没有.ssh目录，里面有id_rsa和id_rsa.pub这两个文件，有创建的话直接跳到第六步，没有就通过以下命令创建： 1$ ssh-keygen -t rsa -C "youremail@example.com" 然后一直回车，直到用户目录里的.ssh目录里找到id_rsa和id_rsa.pub这两个文件。 第六步：SSH KEY加密登录GitHub，找到右上角的头像，点击打开下方的Settings，再选中里面的SSH and GPG KEYS ,点击右上角的New SSH key，把刚才id_rsa.pub里面的内容复制到Title下面的Key内容框里面(title里随便写)，最后点击Add SSH key，这样就完成了SSH Key的加密。 第七步：在GitHub上创建一个仓库点击右上角加号New repository来创建一个仓库，如下图： 创建完成后，需要将本地仓库布置到GitHub上，注意使用语句就需要使用以下语句，每个人都不同，所以就不展示了 这就已经完成了所有的上传步骤，是不是很简单呢？接下来我会就GitHub仓库代码创建网络应用链接进行说明，敬请期待。]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript实战：简易五子棋]]></title>
    <url>%2F2018%2F03%2F01%2FJavaScript%E5%AE%9E%E6%88%98%EF%BC%9A%E7%AE%80%E6%98%93%E4%BA%94%E5%AD%90%E6%A3%8B%2F</url>
    <content type="text"><![CDATA[前几天在慕客网上看见有关JavaScript实现简易五子棋的课程，就自己动手试了一下，这个课程主要是就JavaScript canvas制图实现五子棋的棋子和棋盘，但是这个五子棋还是有一些小bug并且这个五子棋的算法复杂度太高，后期有时间会优化进行算法逻辑的优化。 具体的课程请移步慕课网JS实现人机大战之五子棋（AI篇）和JS实现人机大战之五子棋（UI篇）建议学习顺序先UI后AI,下面附上这次实践的源码。 HTML123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;link rel="stylesheet" href="css/style.css"&gt; &lt;title&gt;五子棋&lt;/title&gt;&lt;/head&gt;&lt;body&gt; //canvas画布 &lt;canvas id="chess" width="450px" height="450px"&gt;&lt;/canvas&gt; &lt;script src="js/javascript.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; CSS12345678910*&#123; margin: 0; padding: 0;&#125;//棋盘的样式#chess&#123; display: block; margin: 50px auto; box-shadow: -2px -2px 2px #efefef, 5px 5px 5px #898989;&#125; JavaScript123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226var chessBoard = [];var me = true;var over = false;// 赢法数组var wins = [];// 赢法的统计数组var myWin = [];var computerWin = [];for (var i = 0; i &lt; 15; i++) &#123; chessBoard[i] = []; for (var j = 0; j &lt; 15; j++) &#123; chessBoard[i][j] = 0; &#125;&#125;for (var i = 0; i &lt; 15; i++) &#123; wins[i] = []; for (var j = 0; j &lt; 15; j++) &#123; wins[i][j] = []; &#125;&#125;var count = 0;//所有的横线for (var i = 0; i &lt; 15; i++) &#123; for (var j = 0; j &lt; 11; j++) &#123; for (var k = 0; k &lt; 5; k++) &#123; wins[i][j + k][count] = true; &#125; count++; &#125;&#125;//所有的竖线for (var i = 0; i &lt; 15; i++) &#123; for (var j = 0; j &lt; 11; j++) &#123; for (var k = 0; k &lt; 5; k++) &#123; wins[j + k][i][count] = true; &#125; count++; &#125;&#125;//所有的斜线for (var i = 0; i &lt; 11; i++) &#123; for (var j = 0; j &lt; 11; j++) &#123; for (var k = 0; k &lt; 5; k++) &#123; wins[i + k][j + k][count] = true; &#125; count++; &#125;&#125;//所有的反斜线for (var i = 0; i &lt; 11; i++) &#123; for (var j = 14; j &gt; 3; j--) &#123; for (var k = 0; k &lt; 5; k++) &#123; wins[i + k][j - k][count] = true; &#125; count++; &#125;&#125;for (var i = 0; i &lt; count; i++) &#123; myWin[i] = 0; computerWin[i] = 0;&#125;var chess = document.getElementById('chess');var context = chess.getContext('2d');context.strokeStyle = '#bfbfbf';var logo = new Image();logo.src = "images/小埋.png";logo.onload = function () &#123; context.drawImage(logo, 0, 0, 450, 450); drawChessBoard();&#125;var drawChessBoard = function () &#123; for (var i = 0; i &lt; 15; i++) &#123; context.moveTo(15 + i * 30, 15); context.lineTo(15 + i * 30, 435); context.stroke(); context.moveTo(15, 15 + i * 30); context.lineTo(435, 15 + i * 30); context.stroke(); &#125;&#125;var oneStep = function (i, j, me) &#123; context.beginPath(); context.arc(15 + i * 30, 15 + j * 30, 13, 0, 2 * Math.PI); context.closePath(); var gradient = context.createRadialGradient(15 + i * 30 + 2, 15 + j * 30 - 2, 13, 15 + i * 30 + 2, 15 + j * 30 - 2, 0); if (me) &#123; gradient.addColorStop(0, "#0a0a0a"); gradient.addColorStop(1, "#636766"); &#125; else &#123; gradient.addColorStop(0, "#d1d1d1"); gradient.addColorStop(1, "#f9f9f9"); &#125; context.fillStyle = gradient; context.fill();&#125;chess.onclick = function (e) &#123; if (over) &#123; return; &#125; if (!me) &#123; return; &#125; var x = e.offsetX; var y = e.offsetY; var i = Math.floor(x / 30); var j = Math.floor(y / 30); if (chessBoard[i][j] == 0) &#123; oneStep(i, j, me); chessBoard[i][j] = 1; &#125; for (var k = 0; k &lt; count; k++) &#123; // if (me == false) if (wins[i][j][k]) &#123; myWin[k]++; computerWin[k] = 6; if (myWin[k] == 5) &#123; alert("你赢了！"); over = true; &#125; &#125; &#125; if (!over) &#123; computerAI(); me = !me; &#125;&#125;var computerAI = function () &#123; var myScore = []; var computerScore = []; var max = 0; var u = 0, v = 0; for (var i = 0; i &lt; 15; i++) &#123; myScore[i] = []; computerScore[i] = []; for (var j = 0; j &lt; 15; j++) &#123; myScore[i][j] = 0; computerScore[i][j] = 0; &#125; &#125; for (var i = 0; i &lt; 15; i++) &#123; for (var j = 0; j &lt; 15; j++) &#123; if (chessBoard[i][j] == 0) &#123; for (var k = 0; k &lt; count; k++) &#123; if (wins[i][j][k]) &#123; if (myWin[k] == 1) &#123; myScore[i][j] += 200; &#125; else if (myWin[k] == 2) &#123; myScore[i][j] += 400; &#125; else if (myWin[k] == 3) &#123; myScore[i][j] += 2000; &#125; else if (myWin[k] == 4) &#123; myScore[i][j] += 10000; &#125; if (computerWin[k] == 1) &#123; computerScore[i][j] += 210; &#125; else if (computerWin[k] == 2) &#123; computerScore[i][j] += 420; &#125; else if (computerWin[k] == 3) &#123; computerScore[i][j] += 2100; &#125; else if (computerWin[k] == 4) &#123; computerScore[i][j] += 20000; &#125; &#125; &#125; if (myScore[i][j] &gt; max) &#123; max = myScore[i][j]; u = i; v = j; &#125; else if (myScore[i][j] == max) &#123; if (computerScore[i][j] &gt; computerScore[u][v]) &#123; u = i; v = j; &#125; &#125; if (computerScore[i][j] &gt; max) &#123; max = computerScore[i][j]; u = i; v = j; &#125; else if (computerScore[i][j] == max) &#123; if (myScore[i][j] &gt; myScore[u][v]) &#123; u = i; v = j; &#125; &#125; &#125; &#125; &#125; oneStep(u, v, false); chessBoard[u][v] = 2; for (var k = 0; k &lt; count; k++) &#123; if (wins[u][v][k]) &#123; computerWin[k]++; myWin[k] = 6; if (computerWin[k] == 5) &#123; alert("AI赢了！"); over = true; &#125; &#125; &#125; if (!over) &#123; me = !me; &#125;&#125; 由于本次实战只是简单的JavaScript数组的逻辑，涉及算法很简单，就不进行一一说明，接下来会更新有关的游戏算法，最终代码的试验地址JavaScript简易五子棋]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java探究人类社会的金钱问题]]></title>
    <url>%2F2018%2F02%2F27%2FJava%E6%8E%A2%E7%A9%B6%E4%BA%BA%E7%B1%BB%E7%A4%BE%E4%BC%9A%E7%9A%84%E9%87%91%E9%92%B1%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最近在网上看到一个非常有意思的分钱问题，问题大概内容如下： 房间里有100个人，每个人都有100元钱，他们在玩一个游戏。每轮游戏中，每个人都要拿走一元钱随机给另外一个人，最后这100个人的财富分布是怎样的？ 以下是三个不同的答案，请投票： 我相信大多数人都选B接近正态分布，也就是说第一轮A给B，第二轮B又给A，大家相差都不多，其实不然，正确的答案是C接近幂律分布，这篇文章发表在搜狐财经:该如何面对这个残酷的世界？，对于我们来说，实现模拟更能直观的发现问题的所在，接下来我就使用Java swing编程实现该问题模拟。 窗口和画布窗口选用GUI编程中的JFrame，主要绘图方式使用Graphics2D有关类运用，面板代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273class AlgoFrame extends JFrame &#123; private int canvasWidth; private int canvasHeight; public AlgoFrame(String title, int canvasWidth, int canvasHeight) &#123; super(title); this.canvasWidth = canvasWidth; this.canvasHeight = canvasHeight; //画布的设置 AlgoCanvas canvas = new AlgoCanvas(); setContentPane(canvas); pack(); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setResizable(false); setVisible(true); &#125; public int getCanvasWidth() &#123; return canvasWidth; &#125; public int getCanvasHeight() &#123; return canvasHeight; &#125; //钱数的数组 private int money[]; public void render(int money[]) &#123; this.money = money; repaint(); &#125; //画板 private class AlgoCanvas extends JPanel &#123; public AlgoCanvas() &#123; super(true); &#125; @Override public void paintComponent(Graphics g) &#123; super.paintComponent(g); Graphics2D g2d = (Graphics2D) g; //抗锯齿 RenderingHints hints = new RenderingHints(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON); hints.put(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY); g2d.addRenderingHints(hints); //实现柱状图 int w = canvasWidth / money.length; for (int i = 0; i &lt; money.length; i++) &#123; if (money[i] &gt; 0) &#123; AlgoVisHelper.fillRectangle(g2d, i * w + 1, canvasHeight / 2 - money[i], w - 1, money[i]); AlgoVisHelper.setColor(g2d, AlgoVisHelper.Blue); &#125; else if(money[i]&lt;0)&#123; AlgoVisHelper.fillRectangle(g2d, i * w + 1, canvasHeight / 2, w - 1, -money[i]); AlgoVisHelper.setColor(g2d, AlgoVisHelper.Red); &#125; &#125; &#125; @Override public Dimension getPreferredSize() &#123; return new Dimension(canvasWidth, canvasHeight); &#125; &#125;&#125; 在定义有关的面板类的时候，同时将钱数数组的柱状图的长度和宽度进行定义，更好的进行可视化，由于钱数本题标注可以是负数，那么久本题而言就有两个颜色，红色为负债，蓝色为盈利。 常用工具模版为了方便以后的代码管理，封装了一个常用的工具模版，具体代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class AlgoVisHelper &#123; private AlgoVisHelper() &#123; &#125; //Google标准颜色 public static final Color Red = new Color(0xf44336); public static final Color Pink = new Color(0xe91e63); public static final Color Purple = new Color(0x9c27b0); public static final Color DeepPurple = new Color(0x673ab7); public static final Color INDIGO_COLOR = new Color(0x3f51b5); public static final Color Blue = new Color(0x2196f3); public static final Color LightBlue = new Color(0x03a9f4); public static final Color Cyan = new Color(0x00bcd4); public static final Color Teal = new Color(0x009688); public static final Color Green = new Color(0x4caf50); public static final Color LightGreen = new Color(0x8bc34a); public static final Color Lime = new Color(0xcddc39); public static final Color Yellow = new Color(0xffe83b); public static final Color Amber = new Color(0xffc107); public static final Color Drange = new Color(0xff9800); public static final Color DeepDrange = new Color(0xff5722); public static final Color Brown = new Color(0x795548); public static final Color Grey = new Color(0x9e9e9e); public static final Color BlueGrey = new Color(0x607d8b); public static final Color Black = new Color(0x000000); public static final Color White = new Color(0xffffff); //定义一个空心圆 public static void strokeCircle(Graphics2D g, int x, int y, int r) &#123; Ellipse2D circle = new Ellipse2D.Double(x - r, y - r, 2 * r, 2 * r); g.draw(circle); &#125; //定义一个实心圆 public static void fillCircle(Graphics2D g, int x, int y, int r) &#123; Ellipse2D circle = new Ellipse2D.Double(x - r, y - r, 2 * r, 2 * r); g.fill(circle); &#125; //定义一个空心矩形 public static void strokeRectangle(Graphics2D g, int x, int y, int w, int h) &#123; Rectangle2D rectangle = new Rectangle2D.Double(x, y, w, h); g.draw(rectangle); &#125; //定义一个实心矩形 public static void fillRectangle(Graphics2D g, int x, int y, int w, int h) &#123; Rectangle2D rectangle = new Rectangle2D.Double(x, y, w, h); g.fill(rectangle); &#125; public static void setStrokeWidth(Graphics2D g, int w) &#123; int strokeWidth = w; g.setStroke(new BasicStroke(strokeWidth, BasicStroke.CAP_ROUND, BasicStroke.JOIN_ROUND)); &#125; public static void setColor(Graphics2D g, Color color) &#123; g.setColor(color); &#125; //实现暂停效果（帧动画） public static void pause(int t) &#123; try &#123; Thread.sleep(t); &#125; catch (InterruptedException e) &#123; System.out.println("Error sleeping"); &#125; &#125;&#125; 实现动画接下来就是最重要的一步，有关主类的动画设计，主要是柱状图的动画位置和帧播放速度，最后实现的代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class AlgoVisualizer &#123; private int money[]; private AlgoFrame frame; public AlgoVisualizer(int sceneWidth, int sceneHeight) &#123; money = new int[100]; for (int i = 0; i &lt; money.length; i++) &#123; money[i] = 100; &#125; //线程 EventQueue.invokeLater(() -&gt; &#123; frame = new AlgoFrame("welcome", sceneWidth, sceneHeight); new Thread(() -&gt; &#123; run(); &#125;).start(); &#125;); &#125; //动画效果的实现 private void run() &#123; while (true) &#123; //排列有序 Arrays.sort(money); frame.render(money); //延时 AlgoVisHelper.pause(40); for (int k = 0; k &lt; 50; k++) &#123; for (int i = 0; i &lt; money.length; i++) &#123; int j = (int) (Math.random() * money.length); //钱的给予模拟 money[i] -= 1; money[j] += 1; &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; int sceneWidth = 1000; int sceneHeight = 800; AlgoVisualizer visualizer = new AlgoVisualizer(sceneWidth, sceneHeight); &#125;&#125; 最后的代码模拟图大概跟下图差不多，说明两级分化越来越严重，但大多数人的水平还在一个范围内，我们的世界正是如此，所以我们应该明白，尽管最成功的玩家不一定是最努力的那个，但是努力的人大都混的还不错，所以说，努力才是硬道理！]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客搭建攻略（三）：高级篇【SEO优化】【持续更新】]]></title>
    <url>%2F2017%2F07%2F26%2FHexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%94%BB%E7%95%A5%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E9%AB%98%E7%BA%A7%E7%AF%87%E3%80%90SEO%E4%BC%98%E5%8C%96%E3%80%91%2F</url>
    <content type="text"><![CDATA[经过博客的基础搭建和必要组件的集成后，我们不能让自己的博客仅仅局限于自己使用，我们还得让它在Google和百度上能搜索的到，最好要在搜索的第一页进行展示，借鉴了简书上一些作者的SEO优化方法，优化了一下SEO，发现我也能让自己的博客在Google上排名十分靠前了，上图： 首页 title 优化更改 index.swig 文件(your-hexo-site\themes\next\layout); 将下面的代码 1&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; &#123;% endblock %&#125; 修改成为： 1&#123;% block title %&#125; &#123;&#123; config.title &#125;&#125; - &#123;&#123; theme.description &#125;&#125; &#123;% endblock %&#125; 这时候你的首页会更符合 网站名称 - 网站描述 这习惯了，搜索引擎爬虫也能更好的爬取你的内容了。 添加 sitemap 站点地图1.安装sitemap站点地图自动生成插件 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 2.在主题配置文件中添加一下配置。 1234sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 然后在主题配置文件中修改url为你的域名,例如： 1url: http://http://godlikemeteor.com/ 配置好后，hexo g 就能在 your-hexo-site\public 中生成 sitemap.xml 和 baidusitemap.xml 了;其中第一个是一会要提交给google的，后面那个看名字当然就是提交给Baidu的了； 3.在 your-hexo-site\source 中新建文件 robots.txt: 1234567891011User-agent: *Allow: /Allow: /archives/Allow: /categories/Allow: /tags/ Disallow: /vendors/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/ 4.在 robots.txt 中添加下面的代码： 12Sitemap: http://godlikemeteor.com/sitemap.xmlSitemap: http://godlikemeteor.com/baidusitemap.xml 注：请自行修改为自己的网站域名！ 然后 hexo d -g 提交一下。 注册 Google Search Console注册 Google Search Console根据提示注册好之后，添加你的博客域名。 然后点击域名进入 Search Console 测试robots.txt点击左侧的 robots.txt 测试工具，根据提示提交你的robots.txt。 提交站点地图别忘了我们刚才创建的 sitemap.xml 文件,现在它要派上用场了。点击左侧工具栏的站点地图: 然后点右上角的添加/测试站点地图。输入sitemap先点测试，如果没问题的话，再提交。 Google抓取方式至此，我们只需要使用Google抓取工具就可以实现网站的抓取了，具体内容将会在以后更新，谢谢大家！]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客搭建攻略（二）：进阶篇]]></title>
    <url>%2F2017%2F07%2F20%2FHexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%94%BB%E7%95%A5%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%9B%E9%98%B6%E7%AF%87%2F</url>
    <content type="text"><![CDATA[Hexo 是高效的静态站点生成框架，她基于 Node.js。 通过 Hexo 你可以轻松地使用 Markdown 编写文章，除了 Markdown 本身的语法之外，还可以使用 Hexo 提供的 标签插件 来快速的插入特定形式的内容。在这篇文章中，假定你已经成功安装了 Hexo，并使用 Hexo 提供的命令创建了一个站点。 讲完了基础的博客搭建，下面大家也发现默认的主题并不好看，今天我们要讲解的就是有关next主题的优化。首先， Next使用文档展示了next主题的基本设置和一些集成操作，在这里就不加过多的描述了，今天我要讲的是博客集成的一些功能的实现。 主题设置在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 为了描述方便，在以下说明中，将前者称为 站点配置文件， 后者称为 主题配置文件。 在这里我使用的是Mist主题，你也可以挑选自己喜欢的样式。 添加网易云音乐在实现了简单的页面美化之后，我们需要让自己的博客更加与众不同，想不想在阅读文章的时候让读者来一段轻松的音乐呢？ 首先，我们可以直接登录网易云音乐，点击生成外链播放器。 然后将最后生成的html代码复制到你想要复制的地方就可以添加网易云音乐了。 是不是很棒呢？赶紧get√吧！ 设置网站logo其实设置网站logo跟设置头像一样，在配置文件中引入正确的地址就可以了，但是网站logo对图片是有要求的，我们需要在 Favicon在线制作 工具中制作32*32的.ico图片，然后放在blog/sourse/images下面，在主题配置文件中添加： 1favicon:images/favicon.ico 效果如图所示： 文章末尾添加“本文结束”标记新建passage-end-tag.swig文件在路径\themes\next\layout\_macro中添加passage-end-tag.swig文件，其内容为： 1234&#123;% if theme.passage_end_tag.enabled %&#125;&lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;------ 本文结束 ------&lt;/div&gt;&#123;% endif %&#125; 修改 post.swig文件在\themes\next\layout\_macro\post.swig中，post-body之后，post-footer之前添加如下代码： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include &apos;passage-end-tag.swig&apos; %&#125; &#123;% endif %&#125;&lt;/div&gt; 在主题配置文件中添加字段在主题配置文件``中添加以下字段开启此功能： 123# 文章末尾添加“本文结束”标记passage_end_tag: enabled: true 完成以上设置之后，在每篇文章之后都会添加“本文结束”标记。 不蒜子统计不蒜子统计是一个非常棒的统计功能，在一开始我就非常喜欢使用这个功能，不蒜子统计十分精准，基本上同一个人浏览多次还会显示一个人，可以精确的统计访问人数。 全局配置编辑 主题配置文件 中的 busuanzi_count 的配置项。 当enable: true时，代表开启全局开关。若site_uv、site_pv、page_pv的值均为false时，不蒜子仅作记录而不会在页面上显示。 站点UV配置当site_uv: true时，代表在页面底部显示站点的UV值。 site_uv_header和site_uv_footer为自定义样式配置，相关的值留空时将不显示，可以使用（带特效的）font-awesome。显示效果为[site_uv_header]UV值[site_uv_footer]。 1234# 效果：本站访客数12345人次site_uv: truesite_uv_header: 本站访客数site_uv_footer: 人次 站点PV配置当site_pv: true时，代表在页面底部显示站点的PV值。 site_pv_header和site_pv_footer为自定义样式配置，相关的值留空时将不显示，可以使用（带特效的）font-awesome。显示效果为[site_pv_header]PV值[site_pv_footer]。 1234# 效果：本站总访问量12345次site_pv: truesite_pv_header: 本站总访问量site_pv_footer: 次 单页面PV配置当page_pv: true时，代表在文章页面的标题下显示该页面的PV值（阅读数）。 page_pv_header和page_pv_footer为自定义样式配置，相关的值留空时将不显示，可以使用（带特效的）font-awesome。显示效果为[page_pv_header]PV值[page_pv_footer]。 1234# 效果：本文总阅读量12345次page_pv: truepage_pv_header: 本文总阅读量page_pv_footer: 次 配置好就会显示如下效果： 鼠标点击红心的设置1.将 love.js 文件添加到 \themes\next\source\js\src 文件目录下。2.找到 \themes\next\layout\_layout.swing 文件， 在文件的后面，&lt;/body&gt; 标签之前 添加以下代码： 12&lt;!-- 页面点击小红心 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/love.js&quot;&gt;&lt;/script&gt; 集成友言评论也许有很多小盆友想要在自己的博客里集成评论功能，但是目前支持next最好的就是多说，无奈多说经常炸，自己动手，丰衣足食，经过我多次尝试，我发现友言这款第三方插件非常不错。 注册友言首先，我们进入友言官网，注册新用户，并登录。 获取代码 集成到这里我们就可以改造啦！在目录thems/next/layout/_scripts/third_party/comments下添加友言的模块文件youyan.swig文件，代码如下： 12345678910111213141516&#123;% if not (theme.duoshuo and theme.duoshuo.shortname) and not theme.duoshuo_shortname and not theme.disqus_shortname and not theme.hypercomments_id and not theme.gentie_productKey %&#125; &#123;% if theme.youyan_uid %&#125; &#123;% set uid = theme.youyan_uid %&#125; &#123;% endif %&#125; &#123;% if page.comments %&#125; &lt;!-- UY BEGIN --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://v2.uyan.cc/code/uyan.js?uid=&#123;&#123;uid&#125;&#125;&quot;&gt;&lt;/script&gt; &lt;!-- UY END --&gt; &#123;% endif %&#125;&#123;% endif %&#125; 修改thems/next/layout/_scripts/third_party/comments.swig文件，添加友言脚本的引用。 12345&#123;% include &apos;./comments/duoshuo.swig&apos; %&#125;&#123;% include &apos;./comments/disqus.swig&apos; %&#125;&#123;% include &apos;./comments/youyan.swig&apos; %&#125;&#123;% include &apos;./comments/hypercomments.swig&apos; %&#125;&#123;% include &apos;./comments/gentie.swig&apos; %&#125; 修改themes/next/layout/_partials/comments.swig文件,在endif之前添加友言的div。 1234567891011121314151617181920212223242526272829&#123;% if page.comments %&#125; &lt;div class=&quot;comments&quot; id=&quot;comments&quot;&gt; &#123;% if (theme.duoshuo and theme.duoshuo.shortname) or theme.duoshuo_shortname %&#125; &lt;div class=&quot;ds-thread&quot; data-thread-key=&quot;&#123;&#123; page.path &#125;&#125;&quot; data-title=&quot;&#123;&#123; page.title &#125;&#125;&quot; data-url=&quot;&#123;&#123; page.permalink &#125;&#125;&quot;&gt; &lt;/div&gt; &#123;% elseif theme.facebook_sdk.enable and theme.facebook_comments_plugin.enable %&#125; &lt;div class=&quot;fb-comments&quot; data-href=&quot;&#123;&#123; page.permalink &#125;&#125;&quot; data-numposts=&quot;&#123;&#123; theme.facebook_comments_plugin.num_of_posts &#125;&#125;&quot; data-width=&quot;&#123;&#123; theme.facebook_comments_plugin.width &#125;&#125;&quot; data-colorscheme=&quot;&#123;&#123; theme.facebook_comments_plugin.scheme &#125;&#125;&quot;&gt; &lt;/div&gt; &#123;% elseif theme.disqus_shortname %&#125; &lt;div id=&quot;disqus_thread&quot;&gt; &lt;noscript&gt; Please enable JavaScript to view the &lt;a href=&quot;//disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt; &lt;/noscript&gt; &lt;/div&gt; &#123;% elseif theme.hypercomments_id %&#125; &lt;div id=&quot;hypercomments_widget&quot;&gt;&lt;/div&gt; &#123;% elseif theme.gentie_productKey %&#125; &lt;div id=&quot;cloud-tie-wrapper&quot; class=&quot;cloud-tie-wrapper&quot;&gt;&lt;/div&gt; &#123;% elseif theme.youyan_uid %&#125; &lt;div id=&quot;uyan_frame&quot;&gt;&lt;/div&gt; &#123;% endif %&#125; &lt;/div&gt;&#123;% endif %&#125; 在thems/next/_config.yml中Third Party Services Settings下添加友言的配置信息。 123456789# ---------------------------------------------------------------# Third Party Services Settings# ---------------------------------------------------------------# Duoshuo ShortName#duoshuo_shortname:# youyanyouyan_uid: 你的UID 至此，改造完成。运行hexo clean清理一下目录，hexo g重新生成一次所有的文档，hexo s运行服务器以后，就可以查看评论效果了。 关于RSS很多同学看到别人的博客会集成订阅的功能（RSS），但是next使用文档中完全没有这方面的介绍，所以显得束手无策。金条就教大家如何去生成RSS功能。 插件安装首先需要安装一个Hexo插件： 1$ npm install --save hexo-generator-feed 配置接下来需要在站点配置文件中配置一下，打开站点配置文件，在其中添加： 1234# Extensions## Plugins: http://hexo.io/plugins/plugins:hexo-generate-feed 然后在主题配置文件中配置： 1234# Set rss to false to disable feed link.# Leave rss as empty to use site&apos;s feed link.# Set rss to specific value if you have burned your feed already.rss: /atom.xml 生成 RSS Feed配置完运行代码： 1$ hexo g 重新生成一次，重新生成一次，你会在 ./public文件夹中看到 atom.xml 文件。然后启动服务器查看是否有效，之后再部署到 Github 中。 最后你可以看到： 头像旋转头像旋转就是当你鼠标经过的时候，让自己的头像旋转360度，还是挺炫酷的，快来get√吧！ 修改头像特效主要是修改 Hexo 目录下 \themes\next\source\css\_common\components\sidebar\sidebar-author.styl 文件。 头像圆形的修改修改sidebar-author.styl文件中的.site-author-imagecss样式如下： 123456789101112.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /*头像圆形*/ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px;&#125; 鼠标经过旋转特效修改sidebar-author.styl文件，添加CSS样式img:hover如下代码： 123456img:hover &#123; /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125; 修改 sidebar-author.styl 文件中 .site-author-image CSS 样式如下： 1234567891011121314151617.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.5s ease-out; -moz-transition: -moz-transform 1.5s ease-out; transition: transform 1.5s ease-out;&#125; 头像循环旋转效果修改修改 sidebar-author.styl 文件，添加如下代码： 12345678910111213141516171819202122232425/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(360deg); &#125;&#125; 修改 sidebar-author.styl 文件中 .site-author-image CSS 样式如下： 12345678910111213141516171819202122.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画：animation:动画名称 动画播放时长单位秒或微秒 动画播放的速度曲线linear为匀速 动画播放次数infinite为循环播放; */ -webkit-animation: play 3s linear infinite; -moz-animation: play 3s linear infinite; animation: play 3s linear infinite; /* 鼠标经过头像旋转360度 -webkit-transition: -webkit-transform 1.5s ease-out; -moz-transition: -moz-transform 1.5s ease-out; transition: transform 1.5s ease-out;*/&#125; 鼠标经过停止头像旋转：修改 sidebar-author.styl 文件，添加 CSS 样式 img:hover 如下代码： 123456789img:hover &#123; /* 鼠标经过停止头像旋转 */ -webkit-animation-play-state:paused; animation-play-state:paused; /* 鼠标经过头像旋转360度 -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);*/&#125; 即可实现头像的旋转功能，是不是特别炫酷呢？ 添加Fork Me On Github添加Fork Me On Github挂件。首先拷贝Github挂件样式代码： 1&lt;a href=&quot;https://github.com/you&quot;&gt;&lt;img style=&quot;position: absolute; top: 0; left: 0; border: 0;&quot; src=&quot;https://camo.githubusercontent.com/8b6b8ccc6da3aa5722903da7b58eb5ab1081adee/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f6f72616e67655f6666373630302e706e67&quot; alt=&quot;Fork me on GitHub&quot; data-canonical-src=&quot;https://s3.amazonaws.com/github/ribbons/forkme_left_orange_ff7600.png&quot;&gt;&lt;/a&gt; 接下来修改代码的href为自己的Github地址： 123&lt;a href=&quot;https://github.com/you&quot;&gt;改为:&lt;a href=&quot;https://github.com/hhstore&quot;&gt; 修改hexo主题修改文件: themes/next/layout/_layout.swig打开_layout.swig文件,找到如下对应位置,添加上述样式代码段即可。 123456789101112131415161718192021222324252627282930&lt;!doctype html&gt;&lt;html class=&quot;theme-next &#123;% if theme.use_motion %&#125;use-motion&#123;% endif %&#125; &#123;% if theme.scheme %&#125;theme-next-&#123;&#123; theme.scheme | lower &#125;&#125;&#123;% endif %&#125;&quot;&gt;&lt;head&gt; &#123;% include &apos;_partials/head.swig&apos; %&#125; &lt;title&gt;&#123;% block title %&#125;&#123;% endblock %&#125;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &#123;% include &apos;_partials/old-browsers.swig&apos; %&#125; &lt;div class=&quot;container one-column &#123;% block page_class %&#125;&#123;% endblock %&#125;&quot;&gt; &lt;div class=&quot;headband&quot;&gt;&lt;/div&gt; &lt;!----------- add Fork me on Github ------------&gt; &lt;a href=&quot;https://github.com/hhstore&quot;&gt;&lt;img style=&quot;position: absolute; top: 500; left: 0; border: 0;&quot; src=&quot;https://camo.githubusercontent.com/8b6b8ccc6da3aa5722903da7b58eb5ab1081adee/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f6f72616e67655f6666373630302e706e67&quot; alt=&quot;Fork me on GitHub&quot; data-canonical-src=&quot;https://s3.amazonaws.com/github/ribbons/forkme_left_orange_ff7600.png&quot;&gt;&lt;/a&gt; &lt;!----------- add Fork me on Github ------------&gt; &lt;div id=&quot;header&quot; class=&quot;header&quot;&gt; &lt;div class=&quot;header-inner&quot;&gt; &#123;% include &apos;_partials/header.swig&apos; %&#125; &lt;/div&gt; &lt;/div&gt; &lt;!-------------省略-------------------&gt; &lt;!-------------省略-------------------&gt; &lt;div class=&quot;back-to-top&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 就这样，我们就可以实现左上角的丝带效果了。 添加自定义导航分类之所以添加自定义导航分类是因为现有的导航分类不够用，所以我们需要扩展导航分类。 添加步骤1.新建source/tools/index.md文件。 在/source/ 文件夹,新建 tools目录,并添加一个index.md文件。可以拷贝其他目录(如tags)中的index.md文件。 2.修改主题配置文件参数。 找到menu标签项, 添加子项:tools: /tools 123456789# when running hexo in a subdirectory (e.g. domain.tld/blog), remove leading slashes ( &quot;/archives&quot; -&gt; &quot;archives&quot; )menu: home: / archives: /archives categories: /categories tags: /tags tools: /tools # 添加位置 about: /about #commonweal: /404.html 3.修改themes/next/languages/zh-Hans.yml 123456789101112title: archive: 归档 category: 分类 tag: 标签menu: home: 首页 archives: 归档 categories: 分类 tags: 标签 tools: 工具 # 添加位置 about: 关于 commonweal: 公益404 4.修改完,重新编译部署即可。 1hexo d -g 部署时保证README.md不被渲染相信大家都会发现一般Git仓库下面都有一个README.md来表现这个仓库设立的目的，但是运用hexo布置的时候会被自动渲染，接下来要介绍部署时保证README.md不被渲染的方法。 在Hexo目录下的source根目录下添加一个,README.md。修改Hexo目录下的_config.yml。将skip_render参数的值设置上。skip_render: README.md保存退出即可。 优化你的README.md标签生成生成标签需要进入网站 shields.io ,这个网站可以找到各种README的标签,但是我们主要应用有关自定义标签的方法，这里简单介绍下怎么自定义标签，把网站拉到最下边，可以看到自定义的地方。]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客搭建攻略（一）：基础篇]]></title>
    <url>%2F2017%2F07%2F19%2FHexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%94%BB%E7%95%A5%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E4%BA%8EHexo-Github%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[简介相信程序猿们都有开博客的想法，因为一个博客完美的集分享代码、记录笔记和展示自己等功能为一身。今天就自己搭建的博客给大家分享一下如何搭建基于hexo + GitHub的博客。 搭建的准备Hexo基于Node.js环境，Node.js是一个Javascript运行环境。如果想搭建基于hexo的博客，首先要安装Node.js。 安装Windows平台请到node官网下载安装包进行安装。 Hexo安装好Node.js环境后，就可以通过node来安装Hexo。首先我们在自己的工作目录下，新建一个blog目录，在此目录上我们可以管理自己的博客源代码，进入blog目录，执行以下指令： 1$ cnpm install -g hexo //安装Hexo 1$ hexo init //初始化Hexo 1$ cnpm install //安装依赖包 1$ hexo g //生成静态页面 1$ hexo s //生成本地预览 打开浏览器，输入 http://localhost:4000/ ，看到以下界面说明Hexo安装成功。 部署环境目前的一切都只能在本机预览，既然是博客，就需要上传到网络上让人们访问。当然你可以选择购买服务器来搭建自己的博客，但是本教程是教给大家如何免费的使用GitHub进行博客搭建。所以，我们需要登录GitHub官网进行注册，并实现我们的搭建。 创建仓库首先登录我们的GitHub，在右上角的加号处新建我们的仓库。 如下图，填写仓库名称，千万要注意仓库名称的格式，一定要以“你的GitHub账号.github.io”命名，这个仓库就是你以后访问你博客站点的默认域名。 创建成功后，接下来就需要配置SSH-key。 部署公匙Hexo部署时，采用git协议，为避免暴露账户密码，最好使用证书认证，所以我们需要在Github部署公钥。 进入账号的Personal setting页面，选择SSH and GPG keys，进入密钥配置页面。填入本机公钥，点击Add SSH key，如下图 输入以下指令，测试密钥连接 1ssh -T git@github.com 如果返回Hi yourname! You&#39;ve successfully authenticated, but GitHub does not provide shell access.则说明公钥部署成功。特别提醒，请注意保护本机私钥的安全。 如果本机还没有SSH密钥，请点击下方详细链接，这里就不做介绍了。 步骤请点击 window下配置SSH连接GitHub、GitHub配置ssh key 将blog部署到 GitHub pages 上配置deploy找到blog目录下的配置文件_config.yml【为了方便辨析，下文统一称之为站点配置文件】,用编辑器打开此文件，找到此文件中的deploy字段，按照以下配置： 1234deploy: type: git repository: git@github.com:yourname/yourname.github.io.git branch: master 注意：将yourname改成你自己的GitHub名字！ 设置git身份信息12git config --global user.name "你的用户名"git config --global user.email "你的邮箱" 然后执行以下指令 1cnpm install hexo-deployer-git --save 执行以下指令进行部署 12hexo ghexo d 浏览器打开 https://yourname.github.io 就可以看到刚才本地预览页面,做到这里，恭喜你已经成功将自己的博客传到网站上了。 域名配置尽管到这里你已经可以通过 https://yourname.github.io 来访问自己的博客，但是我想大家也会觉得这种名字很土，想不想加上自己喜欢的域名，特别是.com等解析度很高的域名呢？ 先去买一个域名，什么后缀的都可以，在这里博主推荐购买腾讯云的域名，最近腾讯云有云+校园计划，可以每月花1元钱租一台云服务器，还可以领25块钱的域名优惠券，点击这里哦！腾讯云+校园计划 进域名控制台，在解析里面添加一条CNAME记录，指向yourname.github.io.即可【注意，最后有个点】，具体请看如图配置。 到blog/source目录下创建CNAME文件，添加你要绑定的域名保存。 然后执行部署 12hexo ghexo d 不出意外，这时用自己的域名就可以访问自己的博客站点，如果出错，极可能是DNS数据还没更新，请稍等一段时间再试，DNS数据同步更新一般不会超过48小时。 Hexo 基本操作1234567hexo new"postName" #新建文章hexo new page"pageName" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #将.deploy目录部署到指定空间hexo help # 查看帮助hexo version #查看Hexo的版本 通过这些操作你就能通过git bush来上传你博客的内容了，是不是很简单呢？接下来我还会推出有关next主题的配置和美化的博客，谢谢大家。 部分资料参考 carry学姐的布置篇，也是我的启蒙篇，感谢学姐！]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript文件夹模拟【代码笔记】]]></title>
    <url>%2F2017%2F07%2F18%2FJavaScript%E6%96%87%E4%BB%B6%E5%A4%B9%E6%A8%A1%E6%8B%9F%E3%80%90%E4%BB%A3%E7%A0%81%E7%AC%94%E8%AE%B0%E3%80%91%2F</url>
    <content type="text"><![CDATA[这是这次大实验的编码实现，由于匆忙来不及做可视化。尽管如此我会抽出时间进行可视化的操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187function Node(element,child,parent,brother)&#123; this.data = element; this.child = child; this.parent = parent; this.brother = brother; this.show = show; this.flog = 0;&#125;function show()&#123; return this.data;&#125;function BST()&#123; this.root = new Node('我的电脑',null,null,null); this.insert = insert; this.remove = remove; this.find = find; this.clearFind = clearFind; this.stick = stick; this.rename = rename;&#125;function find(element)&#123; var root = this.root; if(root.child == null)&#123; console.log("本机无文件夹，无法查找你所需要的文件夹！"); &#125; else&#123; var currout = root; while(1)&#123; if((currout.child != null)&amp;&amp;(currout.child.flog != 1))&#123; currout.flog = 1; currout = currout.child; &#125; else&#123; if(currout.data == element)&#123; console.log("查找成功！节点为：" + currout); return currout; &#125; else&#123; currout.flog = 1; if(currout == this.root)&#123; console.log("本机没有你想要查找的文件夹，请确定输入文件夹名称正确！"); return; &#125; else&#123; if(currout.brother != null)&#123; currout = currout.brother; &#125; else&#123; currout = currout.parent; &#125; &#125; &#125; &#125; &#125; &#125;&#125;function clearFind()&#123; var root = this.root; if(root.child == null)&#123; console.log("本机无文件夹,无法清除文件夹标记！"); &#125; else&#123; var currout = root; var count = 0; while(1)&#123; if((currout.child != null)&amp;&amp;((count != 1)||(currout.child.flog == 1)))&#123; currout = currout.child; &#125; else&#123; count = 1; if(currout == this.root)&#123; console.log("清除成功！"); return; &#125; else&#123; currout.flog = 0; if(currout.brother != null)&#123; currout = currout.brother; &#125; else&#123; currout = currout.parent; &#125; &#125; &#125; &#125; &#125;&#125;function insert(parentNodeElement,element)&#123; var newNode = new Node(element,null,null,null); var parent = this.find(parentNodeElement); this.clearFind(); if(parent.child == null)&#123; parent.child = newNode; newNode.parent = parent; &#125; else&#123; newNode.brother = parent.child; parent.child = newNode; newNode.parent = parent; &#125;&#125;function remove(parentNodeElement,element)&#123; var parent = this.find(parentNodeElement); this.clearFind(); var currout = parent.child; var Brother; while(1)&#123; if(parent.child.data == element)&#123; parent.child = parent.child.brother; return; &#125; else&#123; Brother = currout; currout = currout.brother; if(currout.data == element)&#123; Brother.brother = currout.brother; return; &#125; &#125; &#125;&#125;function stick(oldParentNodeElement,newParentNodeElement,element)&#123; var oldold = this.find(oldParentNodeElement); this.clearFind(); var newnew = this.find(newParentNodeElement); this.clearFind(); var findNode = this.find(element); this.clearFind(); if((oldold.child == findNode)&amp;&amp;(findNode.brother == null))&#123; findNode.brother = newnew.child; newnew.child = findNode; findNode.parent = newnew; oldold.child = null; &#125; else if((oldold.child == findNode)&amp;&amp;(findNode.brother != null))&#123; if(newnew.child == null)&#123; newnew.child = findNode; oldold.child = findNode.brother; findNode.brother = null; findNode.parent = newnew; &#125; else&#123; var currout = oldold.child; while(1)&#123; if(currout.brother != null)&#123; currout = currout.brother; &#125; else&#123; currout.brother = findNode; oldold.child = findNode.brother; findNode.brother = null; findNode.parent = newnew; return; &#125; &#125; &#125; &#125; else if((oldold.child != findNode))&#123; while(1)&#123; var currout1 = oldold.child; var father = null; if(currout1.brother != findNode)&#123; father = currout1; currout1 = currout1.brother; &#125; else&#123; father.brother = findNode.brother; findNode.brother = newnew.child; newnew.child = findNode; findNode.parent = newnew; return; &#125; &#125; &#125;&#125;function remove(element,newElement)&#123; var oldold = this.find(element); this.clearFind(); oldold.data = newElement;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 树]]></title>
    <url>%2F2017%2F07%2F17%2FJavaScript-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[树的定义在计算机科学中，树（英语：tree）是一种抽象数据类型（ADT）或是实作这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n&gt;0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：1.每个节点有零个或多个子节点；2.没有父节点的节点称为根节点；3.每一个非根节点有且只有一个父节点；4.除了根节点外，每个子节点可以分为多个不相交的子树。 JavaScript树的结构今天我们要讲的是排序二叉树的JavaScript实现，首先，排序二叉树的节点跟我们双向链表的节点很像，都有两个指针，不同的是，它的指针指向的是它的左孩子和右孩子，具体实现如下： 123456789function Node(element,leftChild,rightChild)&#123; //传入节点的值，左右指针 this.data = element; this.leftChild = leftChild; this.rightChild = rightChild; this.show = show;&#125;function show()&#123; //显示节点的值 return this.data;&#125; 下面我们就要实现树这种数据结构了，每次我们要新建一个树都需要新建一个根节点让其指向null。 1234567891011function BST()&#123; this.root = null; this.insert = insert; //插入节点 this.maxValue = maxValue; //寻找树中的最大值 this.minValue = minValue; //寻找树中的最小值 this.find = find; //寻找树中的某个值 this.preOrder = preOrder; //前序遍历 this.inOrder = inOrder; //中序遍历 this.postOrder = postOrder; //后序遍历 this.remove = remove; //删除某个节点&#125; 首先，我们要实现的就是树的节点的插入，这需要我们调用insert()函数了。 节点的插入节点的插入方法有两种，一种是递归方法插入节点，另外一种是非递归的方法插入节点，这里我采用的是非递归的方法，尽管对内存占用比较大，但是有助于新手的理解，插入的时候要判定树中是否有节点，没有的话直接变成根节点；如果有节点，循环查找，若比节点小往左走，比节点大往右走，直到往左走遇到空或者往右走遇到空直接插入节点即可，具体编码实现如下： 123456789101112131415161718192021222324252627282930//插入function insert(element)&#123; var node = new Node(element,null,null); if(this.root == null)&#123; this.root = node; //让节点变成根节点 &#125; else&#123; var copy = this.root; //记录根节点的位置 var parents; //记录你找的节点的父节点的位置 while(1)&#123; parents = copy; if(element &lt; copy.data)&#123; //如果小就往左走 copy = copy.leftChild; if(copy == null)&#123; parents.leftChild = node; console.log(parents); break; &#125; &#125; else&#123; copy = copy.rightChild; //如果大就往右走 if(copy == null)&#123; parents.rightChild = node; console.log(parents); break; &#125; &#125; &#125; &#125;&#125; 这就是简单的非递归调用了，接下来我们来试试查找一下我们的树中的节点。 节点的查找节点的查找分为三类：查找树中的最大值，查找树中的最小值，查找树中的某个值。查找的思路很简单，查找树中的某个值就跟插入函数很像，只不过插入函数找到某个节点后插入，而查找只需要返回就行了。查找树中的最大值也很简单，一直找根节点的rightChild直到为空，即为最大值，最小值同理，具体代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465//查找最大值function maxValue()&#123; if(this.root == null)&#123; console.log("此树中无节点！无法获取最大值。"); &#125; else&#123; var copy = this.root; while(1)&#123; if(copy.rightChild != null)&#123; copy = copy.rightChild; &#125; else&#123; console.log(copy.show()); break; &#125; &#125; &#125;&#125;//查找最小值function minValue()&#123; if(this.root == null)&#123; console.log("此树中无节点！无法获取最大值。"); &#125; else&#123; var copy = this.root; while(1)&#123; if(copy.leftChild != null)&#123; copy = copy.leftChild; &#125; else&#123; console.log(copy.show()); break; &#125; &#125; &#125;&#125;//查找某个值，返回节点function find(element)&#123; if(this.root == null)&#123; console.log("此树中无节点！无法获取节点。") &#125; else&#123; var copy = this.root; while(1)&#123; if(element &lt; copy.data)&#123; copy = copy.leftChild; if(copy == null)&#123; console.log("此树中无此节点！请检查数值是否正确。"); break; &#125; &#125; else if(element &gt; copy.data)&#123; copy = copy.rightChild; if(copy == null)&#123; console.log("此树中无此节点！请检查数值是否正确。"); break; &#125; &#125; else if(element == copy.data)&#123; console.log(copy); break; &#125; &#125; &#125;&#125; 写的比较麻烦使让每一步尽可能的清晰，相对于递归调用跟容易理解问题。接下来就轮到我们的遍历问题了。 树的遍历什么是树的遍历在计算机科学里，树的遍历（也称为树的搜索）是图的遍历的一种，指的是按照某种规则，不重复地访问某种树的所有节点的过程。具体的访问操作可能是检查节点的值、更新节点的值等。不同的遍历方式，其访问节点的顺序是不一样的。以下虽然描述的是二叉树的遍历算法，但它们也适用于其他树形结构。 遍历的种类与那些基本上都有标准遍历方式（通常是按线性顺序）的线性数据结构（如链表、一维数组）所不同的是，树结构有多种不同的遍历方式。从二叉树的根节点出发，节点的遍历分为三个主要步骤：对当前节点进行操作（称为“访问”节点）、遍历左边子节点、遍历右边子节点。这三个步骤的先后顺序也是不同遍历方式的根本区别。 由于从给定的某个节点出发，有多个可以前往的下一个节点（树不是线性数据结构），所以在顺序计算（即非并行计算）的情况下，只能推迟对某些节点的访问——即以某种方式保存起来以便稍后再访问。常见的做法是采用栈（LIFO)或队列（FIFO）。由于树本身是一种自我引用（即递归定义）的数据结构，因此很自然也可以用递归方式，或者更准确地说，用corecursion，来实现延迟节点的保存。这时（采用递归的情况）这些节点被保存在call stack中。 遍历方式的命名，源于其访问节点的顺序。最简单的划分：是深度优先（先访问子节点，再访问父节点，最后是第二个子节点）？还是广度优先（先访问第一个子节点，再访问第二个子节点，最后访问父节点）？ 深度优先可进一步按照根节点相对于左右子节点的访问先后来划分。如果把左节点和右节点的位置固定不动，那么根节点放在左节点的左边，称为前序（pre-order）、根节点放在左节点和右节点的中间，称为中序（in-order）、根节点放在右节点的右边，称为后序（post-order）。对广度优先而言，遍历没有前序中序后序之分：给定一组已排序的子节点，其“广度优先”的遍历只有一种唯一的结果。 JavaScript实现树的遍历根据上面的结构设计，我们要实现树的前序遍历，中序遍历和后序遍历。这里我们用递归实现，非常简单，只需要四行代码即可。 123456789101112131415161718192021222324//前序排序function preOrder(node)&#123; if(node != null)&#123; console.log(node.show()); //根 preOrder(node.leftChild); //左子树 preOrder(node.rightChild); //右子树 &#125;&#125;//中序排序function inOrder(node)&#123; if(node != null)&#123; inOrder(node.leftChild); //左子树 console.log(node.show()); //根 inOrder(node.rightChild); //右子树 &#125;&#125;//后序排序function postOrder(node)&#123; if(node != null)&#123; postOrder(node.leftChild); //左子树 postOrder(node.rightChild); //右子树 console.log(node.show()); //根 &#125;&#125; 树节点的删除删除的算法接下来就是最考验脑力的删除操作了，因为在删除的过程中，你要考虑到不同的情况，针对每一种不同的情况，你要有针对性的反应和调整。树的删除具体分为五种情况和三个步骤： 1）判断参数的合法性，判断参数是否在当前的二叉树当中2）删除的节点是根节点，此时应该怎么调整3）删除的节点是普通节点，此时又应该怎么调整 情况一：删除的节点是根节点【即步骤二】情况二：删除的节点是叶子节点情况三：删除的节点只有左孩子没有右孩子情况四：删除的节点只有右孩子没有左孩子情况五：删除的节点既有左孩子也有右孩子 下面直接贴代码进行讲解：【为了更清晰的展示五种情况，将根单独列出来】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115function remove(element)&#123; if(this.root == null)&#123; console.log("此树中无节点！无需删除节点。") //如果树为空， &#125; else&#123; var copy = this.root; //删除节点的寻找 var parents; var findNode; while(1)&#123; if(element &lt; copy.data)&#123; parents = copy; copy = copy.leftChild; if(copy == null)&#123; console.log("此树中无此节点！请检查数值是否正确。"); return; &#125; &#125; else if(element &gt; copy.data)&#123; parents = copy; copy = copy.rightChild; if(copy == null)&#123; console.log("此树中无此节点！请检查数值是否正确。"); return; &#125; &#125; else if(element == copy.data)&#123; findNode = copy; break; &#125; &#125; if(findNode == this.root)&#123; //删除节点为根节点判断四种情况 if((findNode.leftChild == null) &amp;&amp; (findNode.rightChild == null))&#123; findNode = null; &#125; else if((findNode.leftChild == null)&amp;&amp;(findNode.rightChild != null))&#123; findNode.data = findNode.rightChild.data; findNode.rightChild = findNode.rightChild.rightChild; findNode.leftChild = findNode.rightChild.leftChild; &#125; else if((findNode.leftChild != null)&amp;&amp;(findNode.rightChild == null))&#123; findNode.data = findNode.leftChild.data; findNode.rightChild = findNode.leftChild.rightChild; findNode.leftChild = findNode.leftChild.leftChild; &#125; else if((findNode.leftChild != null)&amp;&amp;(findNode.rightChild != null))&#123; var code = findNode.leftChild; var studio; while(1)&#123; if(code.rightChild != null)&#123; studio = code; code = code.rightChild; &#125; else&#123; break; &#125; &#125; if(code==findNode.leftChild)&#123; findNode.data = code.data; findNode.leftChild = code.leftChild; &#125; else&#123; findNode.data = code.data; studio.rightChild = code.leftChild; &#125; &#125; &#125; else&#123; // 不是根节点的四种情况 if((findNode.leftChild == null) &amp;&amp; (findNode.rightChild == null))&#123; if(findNode.data &gt; parents.data)&#123; parents.rightChild = null; &#125; else&#123; parents.leftChild = null; &#125; &#125; else if((findNode.leftChild == null)&amp;&amp;(findNode.rightChild != null))&#123; if(findNode.data &gt; parents.data)&#123; parents.rightChild = findNode.rightChild; &#125; else&#123; parents.leftChild = findNode.rightChild; &#125; &#125; else if((findNode.leftChild != null)&amp;&amp;(findNode.rightChild == null))&#123; if(findNode.data &gt; parents.data)&#123; parents.rightChild = findNode.leftChild; &#125; else&#123; parents.leftChild = findNode.leftChild; &#125; &#125; else if((findNode.leftChild != null)&amp;&amp;(findNode.rightChild != null))&#123; var Chrome = findNode.leftChild; var Google; while(1)&#123; if(Chrome.rightChild != null)&#123; Google = Chrome; Chrome = Chrome.rightChild; &#125; else&#123; break; &#125; &#125; if(Chrome==findNode.leftChild)&#123; findNode.data = Chrome.data; //千万要记住只有一个左孩子的情况，我就错在这里了，报错的是rightChild undefined findNode.leftChild = Chrome.leftChild; &#125; else&#123; findNode.data = Chrome.data; Google.rightChild = Chrome.leftChild; &#125; &#125; &#125; &#125;&#125; 今天的资料就分享到这里，接下来我还会持续更新所学的。谢谢大家。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用JavaScript实现中缀表达式计算器【1.0】]]></title>
    <url>%2F2017%2F07%2F16%2F%E7%94%A8JavaScript%E5%AE%9E%E7%8E%B0%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E7%AE%97%E5%99%A8%2F</url>
    <content type="text"><![CDATA[学习了栈结构，你以为学完了栈？今天要讲的是中缀表达式转后缀表达式，后缀表达式的计算和中缀表达式的计算，接下来让我们开始吧！ 什么是中缀表达式和后缀表达式？中缀表示法（或中缀记法）是一个通用的算术或逻辑公式表示方法， 操作符是以中缀形式处于操作数的中间（例：3 + 4）。与前缀表达式（例：+ 3 4）或后缀表达式（例：3 4 +）相比，中缀表达式不容易被电脑解析，但仍被许多程序语言使用，因为它符合人们的普遍用法。与前缀或后缀记法不同的是，中缀记法中括号是必需的。计算过程中必须用括号将操作符和对应的操作数括起来，用于指示运算的次序。 后缀表示法 (逆波兰表示法)（Reverse Polish notation，RPN，或逆波兰记法），是一种是由波兰数学家扬·武卡谢维奇1920年引入的数学表达式方式，在逆波兰记法中，所有操作符置于操作数的后面，因此也被称为后缀表示法。逆波兰记法不需要括号来标识操作符的优先级。 逆波兰记法中，操作符置于操作数的后面。例如表达“三加四”时，写作“3 4 +”，而不是“3 + 4”。如果有多个操作符，操作符置于第二个操作数的后面，所以常规中缀记法的“3 - 4 + 5”在逆波兰记法中写作“3 4 - 5 +”：先3减去4，再加上5。使用逆波兰记法的一个好处是不需要使用括号。例如中缀记法中“3 - 4 5”与“（3 - 4）5”不相同，但后缀记法中前者写做“3 4 5 -”，无歧义地表示“3 (4 5 ) -”；后者写做“3 4 - 5 *”。逆波兰表达式的解释器一般是基于堆栈的。解释过程一般是：操作数入栈；遇到操作符时，操作数出栈，求值，将结果入栈；当一遍后，栈顶就是表达式的值。因此逆波兰表达式的求值使用堆栈结构很容易实现，并且能很快求值。 首先我们要进行的就是中缀表达式和后缀表达式的转换。开始吧！ 中缀表达式转后缀表达式首先让我们来了解一下有关中缀转后缀的算法，大概有以下几个规则：(1)当读到数字直接送至输出队列中；(2)当读到运算符t时： a.将栈中所有优先级高于或等于t的运算符弹出，送到输出队列中； b.t进栈；(3)读到左括号时总是将它压入栈中；(4)读到右括号时，将靠近栈顶的第一个左括号上面的运算符全部依次弹出，送至输出队列后，再丢弃左括号；(5)中缀表达式全部读完后，若栈中仍有运算符，将其送到输出队列中。 符号的优先级首先我们必须知道有关运算符优先级的问题，经过查阅，我们可以得到如下二维数组。 123456789var sign = new Array(); // + - * / ( ) #sign[0] = new Array('1','1','-1','-1','-1','1','1'); //+sign[1] = new Array('1','1','-1','-1','-1','1','1'); //-sign[2] = new Array('1','1','1','1','-1','1','1'); //*sign[3] = new Array('1','1','1','1','-1','1','1'); ///sign[4] = new Array('-1','-1','-1','-1','-1','0',''); //(sign[5] = new Array('1','1','1','1','','1','1'); //)sign[6] = new Array('-1','-1','-1','-1','-1','','0'); //# 先找横行，代表栈中的运算符，再找纵行，代表你想要比较的运算符，-1代表栈中符号优先级小于栈外符号优先级，栈外符号入栈；1代表栈中符号优先级大于栈外符号优先级，栈中符号弹出，直到栈中符号优先级比栈外符号小，栈外符号入栈；0代表优先级一样，暂时不进行考虑。 符号的比较函数弄清楚符号的优先级，我们就可以对两个符号进行比较，具体实现代码如下： 123456789101112131415function Sign(a,b)&#123; var str = ['+','-','*','/','(',')','#']; var str1; var str2; for(var i=0;i&lt;7;i++)&#123; if(a == str[i])&#123; str1 = i; &#125; if(b == str[i])&#123; str2 = i; &#125; &#125; var count = sign[str1][str2]; return count;&#125; 将符号关系转换为数字更有利于我们之后的判断，接下来就是我们的正题来了。 构造一个栈跟上一篇一样，我们需要构造一个基本的数据结构—-栈，来实现这个项目，不同的是，我们新增加了一个函数peek()来获取栈顶的第一个元素。下面是代码实现： 123456789101112131415161718192021222324252627282930function Stack()&#123; this.dataStore = []; this.top = 0; this.push = push; this.pop = pop; this.length = length; this.peek = peek; this.clear = clear;&#125;function push(element)&#123; this.dataStore[this.top] = element; this.top++;&#125;function pop()&#123; return this.dataStore[--this.top];;&#125;function peek()&#123; return this.dataStore[this.top-1];&#125;function clear()&#123; this.top = 0;&#125;function length()&#123; return this.top;&#125; 构造好一个栈之后，我们就需要进行最重要的步骤了，构造转换函数。 中缀表达式转换函数中缀表达式转后缀表达式跟C语言不同，JavaScript是一种弱类型语言，它的实现更加的灵活，首先我们在栈中先压入#，令最后一个元素能够弹出，然后我们构造如下函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function Change(item)&#123; var str = item; var stack = new Stack(); //构造一个栈 stack.push("#"); //将#压入栈中 var outStack = new Array(); //构造一个队列 var small = ""; var flog = 0; for(var i=0;i&lt;item.length;i++)&#123; if(!isNaN(str[i]) || str[i] == '.')&#123; //如果是数字或者小数点进入循环 if(!isNaN(str[i+1]) || str[i+1] == '.' || flog == 1)&#123; small = small + str[i]; flog = 1; if(isNaN(str[i+1]) &amp;&amp; str[i+1] != '.')&#123; outStack.push(parseFloat(small)); //将整个字符串转换成小数数值后入队 small = ""; flog = 0; &#125; &#125; else&#123; outStack.push(str[i]); &#125; &#125; else&#123; var txt = stack.peek(); if( str[i] == '(')&#123; //遇到左括号直接入栈 stack.push(str[i]); &#125; else if( str[i] == ')')&#123; //遇到右括号将栈中左括号之前的符号全部弹出入队，然后删去左括号 for(var j = i + 1 ; stack.peek() != "(" ; j--)&#123; outStack.push(stack.pop()); &#125; stack.pop(); &#125; else&#123; //两个符号判断关系，选择入队或弹出操作 var relationship = Sign(txt,str[i]); if( relationship == -1)&#123; stack.push(str[i]); &#125; else if(relationship &gt;= 0)&#123; do&#123; outStack.push(stack.pop()); &#125;while(Sign(stack.peek(),str[i])&gt;0); stack.push(str[i]); &#125; &#125; &#125; &#125; console.log(outStack);&#125; 然后我们就可以输入中缀表达式进行计算了，注意在控制台计算的时候在中缀表达式的后面加一个#号，防止栈内符号未完全弹出的情况出现。 测试实例：Change(&#39;1+2*(3-1+2)-3#&#39;);示例输出：1231-2+*+3- 注意，输出的是一个队，也就是一个数组，本样例是为了方便这样测试的。 后缀表达式的计算相对于中缀表达式转后缀表达式，后缀表达式的计算就简单多了，直接上代码，在注释中进行讲解。 1234567891011121314151617181920212223242526272829303132333435363738394041function suffix(item)&#123; var str = item; var outStack = new Stack(); var small = ""; var flog = 0; for(var i=0;i&lt;item.length;i++)&#123; if((!isNaN(str[i]) || str[i] == '.') &amp;&amp; (str[i]!=','))&#123; if(!isNaN(str[i+1]) || str[i+1] == '.' || flog == 1)&#123; small = small + str[i]; flog = 1; if((isNaN(str[i+1]) &amp;&amp; str[i+1] != '.') || (str[i+1]==','))&#123; outStack.push(parseFloat(small)); small = ""; flog = 0; &#125; &#125; else&#123; outStack.push(str[i]); &#125; &#125; else if(str[i]=='+' || str[i]=='-' || str[i]=='*' || str[i]=='/')&#123; var str1 = parseFloat(outStack.pop()); var str2 = parseFloat(outStack.pop()); switch(str[i])&#123; case'+':outStack.push(str2 + str1); break; case'-':outStack.push(str2 - str1); break; case'*':outStack.push(str2 * str1); break; case'/': if(str1 == 0)&#123; alert("对不起，被除数不能为0，请重试！") &#125; outStack.push(str2 / str1); break; &#125; &#125; &#125; return outStack.peek().toFixed(2);&#125; 测试实例：suffix(&#39;1231-2+*+3-&#39;)示例输出：6注意后缀表达式的计算无需将符号入栈，只需要弹出数字进行运算即可。 中缀表达式的计算中缀表达式的计算原理如果你理解了中缀转后缀、后缀运算那么很快你就能够理解，这个例子也是直接在代码中进行讲解。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273function Infix(item)&#123; var str = item; var stack = new Stack(); stack.push("#"); //将#字压入栈 var outStack = new Array(); var small = ""; var flog = 0; for(var i=0;i&lt;item.length;i++)&#123; if(!isNaN(str[i]) || str[i] == '.')&#123; if(!isNaN(str[i+1]) || str[i+1] == '.' || flog == 1)&#123; small = small + str[i]; flog = 1; if(isNaN(str[i+1]) &amp;&amp; str[i+1] != '.')&#123; outStack.push(parseFloat(small)); small = ""; flog = 0; &#125; &#125; else&#123; outStack.push(str[i]); //数字直接入栈 &#125; &#125; else&#123; var txt = stack.peek(); if( str[i] == '(')&#123; stack.push(str[i]); &#125; else if( str[i] == ')')&#123; for(var j = i + 1 ; stack.peek() != "(" ; j--)&#123; //符号判断完不进行入栈操作，而是进行弹出运算 var a1 = parseFloat(outStack.pop()); var a2 = parseFloat(outStack.pop()); var a3 = stack.pop(); switch(a3)&#123; case'+':outStack.push(a2 + a1); break; case'-':outStack.push(a2 - a1); break; case'*':outStack.push(a2 * a1); break; case'/':outStack.push(a2 / a1); break; &#125; &#125; stack.pop(); &#125; else&#123; var relationship = Sign(txt,str[i]); if( relationship == -1)&#123; stack.push(str[i]); &#125; else if(relationship &gt;= 0)&#123; do&#123; var b1 = parseFloat(outStack.pop()); var b2 = parseFloat(outStack.pop()); var a3 = stack.pop(); switch(a3)&#123; case'+':outStack.push(b2 + b1); break; case'-':outStack.push(b2 - b1); break; case'*':outStack.push(b2 * b1); break; case'/':outStack.push(b2 / b1); break; &#125; &#125;while(Sign(stack.peek(),str[i])&gt;0); stack.push(str[i]); &#125; &#125; &#125; &#125; console.log(outStack.pop().toFixed(5)); //将小数位数控制在5位小数，结束运算。&#125; 本代码可以自行尝试输出和输入，根据这个原理以及少许html和CSS的基础就能够写出相当不错的计算器计算器的实现：神奇的计算器 今天的代码就到这里，谢谢大家！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 栈]]></title>
    <url>%2F2017%2F07%2F16%2FJavaScript%20%E6%A0%88%2F</url>
    <content type="text"><![CDATA[什么是栈堆栈（英语：stack），也可直接称栈（港澳台作堆叠），在计算机科学中，是一种特殊的串列形式的数据结构，它的特殊之处在于只能允许在链接串列或阵列的一端（称为堆叠顶端指标，英语：top）进行加入数据（英语：push）和输出数据（英语：pop）的运算。另外栈也可以用一维数组或连结串列的形式来完成。堆叠的另外一个相对的操作方式称为伫列。 由于堆叠数据结构只允许在一端进行操作，因而按照后进先出（LIFO, Last In First Out）的原理运作。 堆叠数据结构使用两种基本操作：推入（push）和弹出（pop）：推入：将数据放入堆叠的顶端（阵列形式或串列形式），堆叠顶端top指标加一。弹出：将顶端数据资料输出（回传），堆叠顶端资料减一。 用JavaScript实现栈的数据结构接下来我们就要使用JavaScript实现栈的数据结构，包含数据的推入和推出。 首先我们定义一个栈 12345678function Stack()&#123; this.data = []; this.top = 0; //记录栈顶位置 this.pop = pop; //右推出 this.push = push; //右进入 this.display = display; this.length = length; //计算数组长度&#125; 注意，top是用来记录栈顶位置，初始化为0，我们使用 push() 函数和 pop()函数来实现。 123456789function push(element)&#123; this.data[this.top] = element; this.top++;&#125;function pop()&#123; var lastElement = this.data[this.top-1]; this.top--; return lastElement;&#125; 而length()函数和display()函数是用来显示栈长度和显示栈内元素的，下面展示函数的实现。 123456789function length()&#123; return this.top;&#125;function display()&#123; var length = this.top; for(var i=0;i&lt;length;i++)&#123; console.log(this.data[i]); &#125;&#125; 今天讲的东西都十分基础，是为了接下来中缀表达式和后缀表达式实现打下基础，接下来的一篇博客中将详解中缀表达式的计算过程。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 循环链表 【约瑟夫斯问题】]]></title>
    <url>%2F2017%2F07%2F15%2FJavaScript%20%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[单向链表和双向链表学完之后，就学到了循环链表，循环链表其实比双向链表简单一点，就是将单向链表的表头和尾指针连接起来，因为跟单向链表很像，在这里我将通过一个小游戏讲解循环链表。 约瑟夫斯问题约瑟夫斯问题（有时也称为约瑟夫斯置换），是一个出现在计算机科学和数学中的问题。在计算机编程的算法中，类似问题又称为约瑟夫环。 有n个囚犯站成一个圆圈，准备处决。首先从一个人开始，越过k-2个人（因为第一个人已经被越过），并杀掉第k个人。接着，再越过k-1个人，并杀掉第k个人。这个过程沿着圆圈一直进行，直到最终只剩下一个人留下，这个人就可以继续活着。问题是，给定了n和k，一开始要站在什么地方才能避免被处决？ 经过改版，本游戏是通过输入总人数和杀人循环权来计算出一个循环链表中的最后一个节点，也就是最后一个幸存者的位置。 编码实现节点的数据结构实现 1234function Node(element)&#123; this.element = element; this.next = null;&#125; 循环链表的实现 123456789101112function LList()&#123; this.head = new Node("head"); this.head.next = this.head; //循环链表的实现 this.find = find; this.insert = insert; this.display = display; this.findPrevious =findPrevious; this.remove = remove; this.findLast = findLast; this.nodegame = nodegame; this.kill = kill;&#125; 实现链表的删除功能 12345678910111213141516function findPrevious(item)&#123; var currNode = this.head; while(!(currNode.next==null)&amp;&amp;(currNode.next.element != item))&#123; currNode = currNode.next; &#125; return currNode;&#125;function remove(item)&#123; var prevNode = this.findPrevious(item); if(!(prevNode.next==null))&#123; curtNode = prevNode.next; prevNode.next = prevNode.next.next; curtNode = null; &#125;&#125; 链表的显示功能 1234567function display()&#123; var currNode = this.head; while(!(currNode == null) &amp;&amp; !(currNode.next.element == 'head'))&#123; console.log(currNode.next.element); currNode =currNode.next; &#125;&#125; 节点的查找 1234567function find(item)&#123; var currNode = this.head; while(currNode.element!=item)&#123; currNode =currNode.next; &#125; return currNode;&#125; 12345678function insert(newElement,item)&#123; var newNode = new Node(newElement); var current = this.find(item); newNode.next = current.next; current.next = newNode; var lastNode = this.findLast(); lastNode.next = this.head; &#125; 杀人游戏的实现 123456789101112131415161718192021222324252627function nodegame(n,x)&#123; var nNode = this.findLast(); for(var i=1;i&lt;=n;i++)&#123; this.insert(i,nNode.element); nNode=nNode.next; &#125; this.kill(n,x); var result = this.findLast().element; this.head.next = this.head; return result;&#125;function kill(num,n)&#123; var count=num-1; var currNode = this.head; while(count)&#123; for(var i=0;i&lt;n;i++)&#123; currNode=currNode.next; if(currNode==this.head)currNode=currNode.next; &#125; this.remove(currNode.element); count--; &#125;&#125;var gal = new LList();function game(playerNum,killNum)&#123; return gal.nodegame(playerNum,killNum);&#125; 特别感谢大佬，喜欢的戳这里→大佬,今天的代码就分享到这里。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 双向链表]]></title>
    <url>%2F2017%2F07%2F15%2FJavaScript%20%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[经过上次的单向链表的讲解，大家可能对链表这种数据结构有了一定的理解，今天要讲的是有关JavaScript双向链表的基本介绍。有关单向链表的基础知识请参考我的博客JavaScript 单向链表 双向链表新建一个链表双向链表跟单向链表的节点结构不同之处就是双向链表有一个前驱，这就需要我们构建一个指向前一个节点的指针。 12345function Node(element)&#123; this.element = element; this.next = null; this.previous = null&#125; 接下来就如单向链表一样创建一个链表。 12345678910function LList()&#123; this.head = new Node("head"); //建立链表的头节点 this.find = find; //查找指定节点 this.insert = insert; //插入节点 this.display = display; //显示所有节点 this.findLast = findLast; //查找最后一个节点 this.remove = remove; //删除指定节点 this.disReverse = disReverse; //链表的反序排列 this.findPrevious = findPrevious;&#125; 至此，一个链表的基本结构就建好了，接下来我们需要通过一系列的功能测试这个链表。 实现链表的查找功能就如单向链表一样，需要我们调用链表的查找函数 find()。 1234567function find(item)&#123; var findNode = this.head; while(findNode.element!=item)&#123; findNode = findNode.next; &#125; return findNode;&#125; 查找函数的参数就是链表的内容，即element。 实现链表的插入功能查找的目的不仅仅是创建一个链表，你也可以通过查找函数确定链表内数据是否正确，接下来需要实现的就是我们的插入函数 insert() 了。 123456789101112131415function insert(newElement,item)&#123; var newNode = new Node(newElement); //创建一个新的节点 var beforeNode = this.find(item); //寻找想插入的前一个元素 if(beforeNode.next!=null)&#123; newNode.next = beforeNode.next; //新创建节点的指针复制 beforeNode.next.previous = newNode; //将新创建节点下一个节点指向新创建的节点 beforeNode.next = newNode; //将前一个节点的指针指向新创建的节点 newNode.previous = beforeNode; //将新建节点的前驱指向上一个节点 &#125; else&#123; newNode.next = beforeNode.next; //新创建节点的指针复制 beforeNode.next = newNode; //将前一个节点的指针指向新创建的节点 newNode.previous = beforeNode; //将新建节点的前驱指向上一个节点 &#125;&#125; newElement是你想要插入节点的内容，而item是你想要插入节点的前一个节点的内容。 实现链表的显示功能通过查找前一个节点，就可以实现在指定节点后插入节点的操作了。接下来检验我们的函数是否可用，就需要调用我们的显示函数 display() 了。 1234567function display()&#123; var findNode = this.head; while(!(findNode.next == null))&#123; console.log(findNode.next.element); findNode = findNode.next; &#125;&#125; display() 需要在Google console 中调用，通过调用你会发现建立了一个完整的链表结构，而且可以随心所欲的更改链表的数据了。 实现链表的删除功能链表的删除功能其实就是将链表的指针指向下下个节点上，因为浏览器的缓存特性，浏览器会自动清除无用的节点，这样便实现了链表节点的删除，但在删除节点之前我们需要找到删除的节点的前一个节点，然后改变指针就可以了。 1234567function findPrevious(item)&#123; var findNode = this.head; while(findNode.next.element!=item)&#123; findNode =findNode.next; &#125; return findNode;&#125; 找到前一个节点，就可以实现我们的删除操作了，删除需要 remove() 函数实现。 12345678910function remove(item)&#123; var findNode = this.findPrevious(item);//找到删除节点的前一个节点 if(findNode.next.next!=null)&#123; findNode.next = findNode.next.next; //将删除节点之后的节点向前移位 findNode.next.next.previous = findNode;//将删除节点的前指针指向删除节点的前一个节点，浏览器自动清除无用的节点 &#125; else&#123; findNode.next = findNode.next.next; //将删除节点之后的节点向前移位 &#125;&#125; 接下来我们可以使用 display() 函数调用，就可以发现已经可以实现功能了。 实现链表的反序排序功能双向链表区别于单向链表最重要的功能就是反向排序，反向排序需要我们找到最后一个节点，然后通过前驱依次遍历，首先我们需要 findLast() 实现查找最后一个节点。 1234567function findLast()&#123; var findNode = this.head; //找到表头 while(!(findNode.next == null))&#123; //查找是否节点的后驱指针为空 findNode = findNode.next; &#125; return findNode;&#125; 然后直接调用排序函数就可以实现链表的反向排序输出了。 12345678function disReverse()&#123; var findNode = this.head; findNode = this.findLast(); while(!(findNode.previous == null))&#123; console.log(findNode.element); findNode = findNode.previous; &#125;&#125; 通过这次讲解是不是对链表这种数据结构产生了兴趣？接下来还会推出有关循环链表的博客，也会给大家讲一个小游戏，敬请期待！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不得不知道的Git命令]]></title>
    <url>%2F2017%2F07%2F12%2F%E4%BD%A0%E4%B8%8D%E5%BE%97%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Git%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[GitHub是一个通过Git进行版本控制的软件源代码托管服务，由GitHub公司（曾称Logical Awesome）的开发者Chris Wanstrath、PJ Hyett和Tom Preston-Werner使用Ruby on Rails编写而成。 GitHub同时提供付费账户和免费账户。这两种账户都可以创建公开的代码仓库，但是付费账户还可以创建私有的代码仓库。根据在2009年的Git用户调查，GitHub是最流行的Git访问站点。除了允许个人和组织创建和访问保管中的代码以外，它也提供了一些方便社会化共同软件开发的功能，即一般人口中的社区功能，包括允许用户追踪其他用户、组织、软件库的动态，对软件代码的改动和bug提出评论等。GitHub也提供了图表功能，用于概观显示开发者们怎样在代码库上工作以及软件的开发活跃程度。 经过几天的博客搭建，终于搭好了自己的博客，在这个过程中我也发现有一些Git指令不是特别会写，所以查阅了很多资料，总结在这里，也作为一些参考。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586git init # 初始化本地git仓库（创建新仓库）git config --global user.name "xxx" # 配置用户名git config --global user.email "xxx@xxx.com" # 配置邮件git config --global color.ui true # git status等命令自动着色git config --global color.status autogit config --global color.diff autogit config --global color.branch autogit config --global color.interactive autogit config --global --unset http.proxy # remove proxy configuration on gitgit clone git+ssh://git@192.168.53.168/VT.git # clone远程仓库git status # 查看当前版本状态（是否修改）git add xyz # 添加xyz文件至indexgit add . # 增加当前子目录下所有更改过的文件至indexgit commit -m 'xxx' # 提交git commit --amend -m 'xxx' # 合并上一次提交（用于反复修改）git commit -am 'xxx' # 将add和commit合为一步git rm xxx # 删除index中的文件git rm -r * # 递归删除git log # 显示提交日志git log -1 # 显示1行日志 -n为n行git log -5git log --stat # 显示提交日志及相关变动文件git log -p -mgit show dfb02e6e4f2f7b573337763e5c0013802e392818 # 显示某个提交的详细内容git show dfb02 # 可只用commitid的前几位git show HEAD # 显示HEAD提交日志git show HEAD^ # 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本git tag # 显示已存在的taggit tag -a v2.0 -m 'xxx' # 增加v2.0的taggit show v2.0 # 显示v2.0的日志及详细内容git log v2.0 # 显示v2.0的日志git diff # 显示所有未添加至index的变更git diff --cached # 显示所有已添加index但还未commit的变更git diff HEAD^ # 比较与上一个版本的差异git diff HEAD -- ./lib # 比较与HEAD版本lib目录的差异git diff origin/master..master # 比较远程分支master上有本地分支master上没有的git diff origin/master..master --stat # 只显示差异的文件，不显示具体内容git remote add origin git+ssh://git@192.168.53.168/VT.git # 增加远程定义（用于push/pull/fetch）git branch # 显示本地分支git branch --contains 50089 # 显示包含提交50089的分支git branch -a # 显示所有分支git branch -r # 显示所有原创分支git branch --merged # 显示所有已合并到当前分支的分支git branch --no-merged # 显示所有未合并到当前分支的分支git branch -m master master_copy # 本地分支改名git checkout -b master_copy # 从当前分支创建新分支master_copy并检出git checkout -b master master_copy # 上面的完整版git checkout features/performance # 检出已存在的features/performance分支git checkout --track hotfixes/BJVEP933 # 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支git checkout v2.0 # 检出版本v2.0git checkout -b devel origin/develop # 从远程分支develop创建新本地分支devel并检出git checkout -- README # 检出head版本的README文件（可用于修改错误回退）git merge origin/master # 合并远程master分支至当前分支git cherry-pick ff44785404a8e # 合并提交ff44785404a8e的修改git push origin master # 将当前分支push到远程master分支git push origin :hotfixes/BJVEP933 # 删除远程仓库的hotfixes/BJVEP933分支git push --tags # 把所有tag推送到远程仓库git fetch # 获取所有远程分支（不更新本地分支，另需merge）git fetch --prune # 获取所有原创分支并清除服务器上已删掉的分支git pull origin master # 获取远程分支master并merge到当前分支git mv README README2 # 重命名文件README为README2git reset --hard HEAD # 将当前版本重置为HEAD（通常用于merge失败回退）git rebasegit branch -d hotfixes/BJVEP933 # 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）git branch -D hotfixes/BJVEP933 # 强制删除分支hotfixes/BJVEP933git ls-files # 列出git index包含的文件git show-branch # 图示当前分支历史git show-branch --all # 图示所有分支历史git whatchanged # 显示提交历史对应的文件修改git revert dfb02e6e4f2f7b573337763e5c0013802e392818 # 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818git ls-tree HEAD # 内部命令：显示某个git对象git rev-parse v2.0 # 内部命令：显示某个ref对于的SHA1 HASHgit reflog # 显示所有提交，包括孤立节点git show HEAD@&#123;5&#125;git show master@&#123;yesterday&#125; # 显示master分支昨天的状态git log --pretty=format:'%h %s' --graph # 图示提交日志git show HEAD~3git show -s --pretty=raw 2be7fcb476git stash # 暂存当前修改，将所有至为HEAD状态git stash list # 查看所有暂存git stash show -p stash@&#123;0&#125; # 参考第一次暂存git stash apply stash@&#123;0&#125; # 应用第一次暂存git grep "delete from" # 文件中搜索文本“delete from”git grep -e '#define' --and -e SORT_DIRENTgit gcgit fsck]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 单向链表]]></title>
    <url>%2F2017%2F07%2F11%2FJavaScript%20%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[欢迎大家来到我的博客，这是我的第一篇技术性博客，今天给大家讲解有关于JavaScript单向链表的建立和操作过程，希望大家能够从中收获到知识，我也会定期更新自己所学的知识到这个博客上。 链表新建一个链表链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。链表中最简单的一种是单向链表，它包含两个域，一个信息域和一个指针域。JavaScript中的单向链表也是如此，建立一个链表我们首先先要建立一个最基础的属性：节点 1234function Node(element)&#123; this.element = element; this.next = null;&#125; 因为JavaScript是一种弱类型的语言，所以使用函数定义节点，而next即为节点的指针，接下来就要创建我们的链表了，但是光有链表还不够，还需要一些链表的操作，添加节点的查找、插入、显示和删除四个功能。 12345678function LList()&#123; this.head = new Node("head"); this.find = find; this.insert = insert; this.display = display; this.findPrevious = findPrevious; this.remove = remove; &#125; 至此，一个链表的基本结构就建好了，接下来我们需要通过一系列的功能测试这个链表 实现链表的查找功能尽管已经建立出一个链表，但是因为这个链表只包含一个头节点，所以我们要插入自己想要的数据，但是如何确定插入元素在什么位置上呢？这就需要我们调用链表的查找函数 find() 了。 1234567function find(item)&#123; var findNode = this.head; while(findNode.element!=item)&#123; findNode = findNode.next; &#125; return findNode;&#125; 查找函数的参数就是链表的内容，即element。 实现链表的插入功能查找的目的不仅仅是创建一个链表，你也可以通过查找函数确定链表内数据是否正确，接下来需要实现的就是我们的插入函数 insert() 了。 123456function insert(newElement,item)&#123; var newNode = new Node(newElement); var beforeNode = this.find(item); newNode.next = beforeNode.next; beforeNode.next = newNode; &#125; newElement是你想要插入节点的内容，而item是你想要插入节点的前一个节点的内容。 实现链表的显示功能通过查找前一个节点，就可以实现在指定节点后插入节点的操作了。接下来检验我们的函数是否可用，就需要调用我们的显示函数 display() 了。 1234567function display()&#123; var findNode = this.head; while(!(findNode.next == null))&#123; console.log(findNode.next.element); findNode = findNode.next; &#125;&#125; display() 需要在Google console 中调用，通过调用你会发现建立了一个完整的链表结构，而且可以随心所欲的更改链表的数据了。 实现链表的删除功能链表的删除功能其实就是将链表的指针指向下下个节点上，因为浏览器的缓存特性，浏览器会自动清除无用的节点，这样便实现了链表节点的删除，但在删除节点之前我们需要找到删除的节点的前一个节点，然后改变指针就可以了。 1234567function findPrevious(item)&#123; var findNode = this.head; while(findNode.next.element!=item)&#123; findNode =findNode.next; &#125; return findNode;&#125; 找到前一个节点，就可以实现我们的删除操作了，删除需要 remove() 函数实现。 1234function remove(item)&#123; var findNode = this.findPrevious(item); findNode.next = findNode.next.next;&#125; 接下来我们可以使用 display() 函数调用，就可以发现已经可以实现功能了，这是最基本的链表操作，接下来还会推出有关双向链表等博客，谢谢大家支持！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2016%2F11%2F09%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>搭建博客</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>npm</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
