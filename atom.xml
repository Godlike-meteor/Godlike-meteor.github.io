<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Godlike Meteor</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.godlikemeteor.com/"/>
  <updated>2017-07-16T14:05:15.040Z</updated>
  <id>http://www.godlikemeteor.com/</id>
  
  <author>
    <name>Godlike Meteor</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>用JavaScript实现中缀表达式计算器【1.0】</title>
    <link href="http://www.godlikemeteor.com/2017/07/16/%E7%94%A8JavaScript%E5%AE%9E%E7%8E%B0%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E7%AE%97%E5%99%A8/"/>
    <id>http://www.godlikemeteor.com/2017/07/16/用JavaScript实现中缀表达式计算器/</id>
    <published>2017-07-16T12:16:34.000Z</published>
    <updated>2017-07-16T14:05:15.040Z</updated>
    
    <content type="html"><![CDATA[<p>学习了栈结构，你以为学完了栈？今天要讲的是中缀表达式转后缀表达式，后缀表达式的计算和中缀表达式的计算，接下来让我们开始吧！</p>
<h2 id="什么是中缀表达式和后缀表达式？"><a href="#什么是中缀表达式和后缀表达式？" class="headerlink" title="什么是中缀表达式和后缀表达式？"></a>什么是中缀表达式和后缀表达式？</h2><p>中缀表示法（或中缀记法）是一个通用的算术或逻辑公式表示方法， 操作符是以中缀形式处于操作数的中间（例：3 + 4）。与前缀表达式（例：+ 3 4）或后缀表达式（例：3 4 +）相比，中缀表达式不容易被电脑解析，但仍被许多程序语言使用，因为它符合人们的普遍用法。<br>与前缀或后缀记法不同的是，中缀记法中括号是必需的。计算过程中必须用括号将操作符和对应的操作数括起来，用于指示运算的次序。</p>
<p>后缀表示法 (逆波兰表示法)（Reverse Polish notation，RPN，或逆波兰记法），是一种是由波兰数学家扬·武卡谢维奇1920年引入的数学表达式方式，在逆波兰记法中，所有操作符置于操作数的后面，因此也被称为后缀表示法。逆波兰记法不需要括号来标识操作符的优先级。</p>
<p>逆波兰记法中，操作符置于操作数的后面。例如表达“三加四”时，写作“3 4 +”，而不是“3 + 4”。如果有多个操作符，操作符置于第二个操作数的后面，所以常规中缀记法的“3 - 4 + 5”在逆波兰记法中写作“3 4 - 5 +”：先3减去4，再加上5。使用逆波兰记法的一个好处是不需要使用括号。例如中缀记法中“3 - 4 <em> 5”与“（3 - 4）</em>5”不相同，但后缀记法中前者写做“3 4 5 <em> -”，无歧义地表示“3 (4 5 </em>) -”；后者写做“3 4 - 5 *”。<br>逆波兰表达式的解释器一般是基于堆栈的。解释过程一般是：操作数入栈；遇到操作符时，操作数出栈，求值，将结果入栈；当一遍后，栈顶就是表达式的值。因此逆波兰表达式的求值使用堆栈结构很容易实现，并且能很快求值。</p>
<p>首先我们要进行的就是中缀表达式和后缀表达式的转换。开始吧！</p>
<h2 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式"></a>中缀表达式转后缀表达式</h2><p>首先让我们来了解一下有关中缀转后缀的算法，大概有以下几个规则：<br>(1)当读到数字直接送至输出队列中；<br>(2)当读到运算符t时：<br>    a.将栈中所有优先级高于或等于t的运算符弹出，送到输出队列中；<br>　  b.t进栈；<br>(3)读到左括号时总是将它压入栈中；<br>(4)读到右括号时，将靠近栈顶的第一个左括号上面的运算符全部依次弹出，送至输出队列后，再丢弃左括号；<br>(5)中缀表达式全部读完后，若栈中仍有运算符，将其送到输出队列中。 </p>
<h3 id="符号的优先级"><a href="#符号的优先级" class="headerlink" title="符号的优先级"></a>符号的优先级</h3><p>首先我们必须知道有关运算符优先级的问题，经过查阅，我们可以得到如下二维数组。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var sign = new Array();</div><div class="line">                    // +   -   *    /    (    )   <span class="comment">#</span></div><div class="line">sign[0] = new Array(<span class="string">'1'</span>,<span class="string">'1'</span>,<span class="string">'-1'</span>,<span class="string">'-1'</span>,<span class="string">'-1'</span>,<span class="string">'1'</span>,<span class="string">'1'</span>);   //+</div><div class="line">sign[1] = new Array(<span class="string">'1'</span>,<span class="string">'1'</span>,<span class="string">'-1'</span>,<span class="string">'-1'</span>,<span class="string">'-1'</span>,<span class="string">'1'</span>,<span class="string">'1'</span>);   //-</div><div class="line">sign[2] = new Array(<span class="string">'1'</span>,<span class="string">'1'</span>,<span class="string">'1'</span>,<span class="string">'1'</span>,<span class="string">'-1'</span>,<span class="string">'1'</span>,<span class="string">'1'</span>);     //*</div><div class="line">sign[3] = new Array(<span class="string">'1'</span>,<span class="string">'1'</span>,<span class="string">'1'</span>,<span class="string">'1'</span>,<span class="string">'-1'</span>,<span class="string">'1'</span>,<span class="string">'1'</span>);     ///</div><div class="line">sign[4] = new Array(<span class="string">'-1'</span>,<span class="string">'-1'</span>,<span class="string">'-1'</span>,<span class="string">'-1'</span>,<span class="string">'-1'</span>,<span class="string">'0'</span>,<span class="string">''</span>);  //(</div><div class="line">sign[5] = new Array(<span class="string">'1'</span>,<span class="string">'1'</span>,<span class="string">'1'</span>,<span class="string">'1'</span>,<span class="string">''</span>,<span class="string">'1'</span>,<span class="string">'1'</span>);       //)</div><div class="line">sign[6] = new Array(<span class="string">'-1'</span>,<span class="string">'-1'</span>,<span class="string">'-1'</span>,<span class="string">'-1'</span>,<span class="string">'-1'</span>,<span class="string">''</span>,<span class="string">'0'</span>);  //<span class="comment">#</span></div></pre></td></tr></table></figure>
<p>先找横行，代表栈中的运算符，再找纵行，代表你想要比较的运算符，<code>1</code>代表栈中符号优先级小于栈外符号优先级，栈外符号入栈；<code>-1</code>代表栈中符号优先级大于栈外符号优先级，栈中符号弹出，直到栈中符号优先级比栈外符号小，栈外符号入栈；<code>0</code>代表优先级一样，暂时不进行考虑。</p>
<h3 id="符号的比较函数"><a href="#符号的比较函数" class="headerlink" title="符号的比较函数"></a>符号的比较函数</h3><p>弄清楚符号的优先级，我们就可以对两个符号进行比较，具体实现代码如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> Sign(a,b)&#123;</div><div class="line">    var str = [<span class="string">'+'</span>,<span class="string">'-'</span>,<span class="string">'*'</span>,<span class="string">'/'</span>,<span class="string">'('</span>,<span class="string">')'</span>,<span class="string">'#'</span>];</div><div class="line">    var str1;</div><div class="line">    var str2;</div><div class="line">    <span class="keyword">for</span>(var i=0;i&lt;7;i++)&#123;</div><div class="line">        <span class="keyword">if</span>(a == str[i])&#123;</div><div class="line">            str1 = i;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(b == str[i])&#123;</div><div class="line">            str2 = i;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    var count = sign[str1][str2];</div><div class="line">    <span class="built_in">return</span> count;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>将符号关系转换为数字更有利于我们之后的判断，接下来就是我们的正题来了。</p>
<h3 id="构造一个栈"><a href="#构造一个栈" class="headerlink" title="构造一个栈"></a>构造一个栈</h3><p>跟上一篇一样，我们需要构造一个基本的数据结构—-栈，来实现这个项目，不同的是，我们新增加了一个函数<code>peek()</code>来获取栈顶的第一个元素。下面是代码实现：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">Stack</span></span>()&#123;</div><div class="line">    this.dataStore = [];</div><div class="line">    this.top = 0;</div><div class="line">    this.push = push;</div><div class="line">    this.pop = pop;</div><div class="line">    this.length = length;</div><div class="line">    this.peek = peek;</div><div class="line">    this.clear = clear;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">function</span> push(element)&#123;</div><div class="line">    this.dataStore[this.top] = element;</div><div class="line">    this.top++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">pop</span></span>()&#123;</div><div class="line">    <span class="built_in">return</span> this.dataStore[--this.top];;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">peek</span></span>()&#123;</div><div class="line">    <span class="built_in">return</span> this.dataStore[this.top-1];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">clear</span></span>()&#123;</div><div class="line">    this.top = 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">length</span></span>()&#123;</div><div class="line">    <span class="built_in">return</span> this.top;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>构造好一个栈之后，我们就需要进行最重要的步骤了，构造转换函数。</p>
<h3 id="中缀表达式转换函数"><a href="#中缀表达式转换函数" class="headerlink" title="中缀表达式转换函数"></a>中缀表达式转换函数</h3><p>中缀表达式转后缀表达式跟C语言不同，JavaScript是一种弱类型语言，它的实现更加的灵活，首先我们在栈中先压入<code>#</code>，令最后一个元素能够弹出，然后我们构造如下函数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> Change(item)&#123;</div><div class="line">    var str = item;</div><div class="line">    var stack = new Stack();                       //构造一个栈</div><div class="line">    stack.push(<span class="string">"#"</span>);                               //将<span class="comment">#压入栈中</span></div><div class="line">    var outStack = new Array();                    //构造一个队列</div><div class="line">    var small = <span class="string">""</span>;</div><div class="line">    var flog = 0;</div><div class="line">    <span class="keyword">for</span>(var i=0;i&lt;item.length;i++)&#123;</div><div class="line">        <span class="keyword">if</span>(!isNaN(str[i]) || str[i] == <span class="string">'.'</span>)&#123;       //如果是数字或者小数点进入循环</div><div class="line">            <span class="keyword">if</span>(!isNaN(str[i+1]) || str[i+1] == <span class="string">'.'</span> || flog == 1)&#123;</div><div class="line">                small = small + str[i];</div><div class="line">                flog = 1;</div><div class="line">                <span class="keyword">if</span>(isNaN(str[i+1]) &amp;&amp; str[i+1] != <span class="string">'.'</span>)&#123;</div><div class="line">                    outStack.push(parseFloat(small));    //将整个字符串转换成小数数值后入队</div><div class="line">                    small = <span class="string">""</span>;</div><div class="line">                    flog = 0;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                outStack.push(str[i]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            var txt = stack.peek();</div><div class="line">            <span class="keyword">if</span>( str[i] == <span class="string">'('</span>)&#123;              //遇到左括号直接入栈</div><div class="line">                stack.push(str[i]);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( str[i] == <span class="string">')'</span>)&#123;         //遇到右括号将栈中左括号之前的符号全部弹出入队，然后删去左括号</div><div class="line">                <span class="keyword">for</span>(var j = i + 1 ; stack.peek() != <span class="string">"("</span> ; j--)&#123;</div><div class="line">                    outStack.push(stack.pop());</div><div class="line">                &#125;</div><div class="line">                stack.pop();                     </div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;                            //两个符号判断关系，选择入队或弹出操作</div><div class="line">                var relationship = Sign(txt,str[i]);</div><div class="line">                <span class="keyword">if</span>( relationship == -1)&#123;</div><div class="line">                    stack.push(str[i]);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(relationship &gt;= 0)&#123;</div><div class="line">                    <span class="keyword">do</span>&#123;</div><div class="line">                        outStack.push(stack.pop());</div><div class="line">                    &#125;<span class="keyword">while</span>(Sign(stack.peek(),str[i])&gt;0);</div><div class="line">                    stack.push(str[i]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    console.log(outStack);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们就可以输入中缀表达式进行计算了，注意在控制台计算的时候在中缀表达式的后面加一个#号，防止栈内符号未完全弹出的情况出现。</p>
<p>测试实例：<code>Change(&#39;1+2*(3-1+2)-3#&#39;);</code><br>示例输出：<code>1231-2+*+3-</code> 注意，输出的是一个队，也就是一个数组，本样例是为了方便这样测试的。</p>
<h2 id="后缀表达式的计算"><a href="#后缀表达式的计算" class="headerlink" title="后缀表达式的计算"></a>后缀表达式的计算</h2><p>相对于中缀表达式转后缀表达式，后缀表达式的计算就简单多了，直接上代码，在注释中进行讲解。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">ffunction suffix(item)&#123;</div><div class="line">    var str = item;</div><div class="line">    var outStack = new Stack();</div><div class="line">    var small = <span class="string">""</span>;</div><div class="line">    var flog = 0;</div><div class="line">    <span class="keyword">for</span>(var i=0;i&lt;item.length;i++)&#123;</div><div class="line">        <span class="keyword">if</span>(!isNaN(str[i]) || str[i] == <span class="string">'.'</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(!isNaN(str[i+1]) || str[i+1] == <span class="string">'.'</span> || flog == 1)&#123;</div><div class="line">                small = small + str[i];</div><div class="line">                flog = 1;</div><div class="line">                <span class="keyword">if</span>(isNaN(str[i+1]) &amp;&amp; str[i+1] != <span class="string">'.'</span>)&#123;</div><div class="line">                    outStack.push(parseFloat(small));</div><div class="line">                    small = <span class="string">""</span>;</div><div class="line">                    flog = 0;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                outStack.push(str[i]);                 //数字直接入栈</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            var str1 = parseFloat(outStack.pop());     //遇到符号将栈顶的两个数字弹出</div><div class="line">            var str2 = parseFloat(outStack.pop());     //后弹出的在前，先弹出的在后进行运算</div><div class="line">            switch(str[i])&#123;</div><div class="line">                <span class="keyword">case</span><span class="string">'+'</span>:outStack.push(str2 + str1);</div><div class="line">                <span class="built_in">break</span>;</div><div class="line">                <span class="keyword">case</span><span class="string">'-'</span>:outStack.push(str2 - str1);</div><div class="line">                <span class="built_in">break</span>;</div><div class="line">                <span class="keyword">case</span><span class="string">'*'</span>:outStack.push(str2 * str1);</div><div class="line">                <span class="built_in">break</span>;</div><div class="line">                <span class="keyword">case</span><span class="string">'/'</span>:outStack.push(str2 / str1);</div><div class="line">                <span class="built_in">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    console.log(outStack.peek());         //直到栈中只有一个数字，显示即可，就是本次的运算结果</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试实例：<code>suffix(&#39;1231-2+*+3-&#39;)</code><br>示例输出：<code>6</code><br>注意后缀表达式的计算无需将符号入栈，只需要弹出数字进行运算即可。</p>
<h2 id="中缀表达式的计算"><a href="#中缀表达式的计算" class="headerlink" title="中缀表达式的计算"></a>中缀表达式的计算</h2><p>中缀表达式的计算原理如果你理解了中缀转后缀、后缀运算那么很快你就能够理解，这个例子也是直接在代码中进行讲解。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> Infix(item)&#123;</div><div class="line">    var str = item;</div><div class="line">    var stack = new Stack();</div><div class="line">    stack.push(<span class="string">"#"</span>);                       //将<span class="comment">#字压入栈</span></div><div class="line">    var outStack = new Array();</div><div class="line">    var small = <span class="string">""</span>;</div><div class="line">    var flog = 0;</div><div class="line">    <span class="keyword">for</span>(var i=0;i&lt;item.length;i++)&#123;</div><div class="line">        <span class="keyword">if</span>(!isNaN(str[i]) || str[i] == <span class="string">'.'</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(!isNaN(str[i+1]) || str[i+1] == <span class="string">'.'</span> || flog == 1)&#123;</div><div class="line">                small = small + str[i];</div><div class="line">                flog = 1;</div><div class="line">                <span class="keyword">if</span>(isNaN(str[i+1]) &amp;&amp; str[i+1] != <span class="string">'.'</span>)&#123;</div><div class="line">                    outStack.push(parseFloat(small));</div><div class="line">                    small = <span class="string">""</span>;</div><div class="line">                    flog = 0;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                outStack.push(str[i]);   //数字直接入栈</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            var txt = stack.peek();</div><div class="line">            <span class="keyword">if</span>( str[i] == <span class="string">'('</span>)&#123;</div><div class="line">                stack.push(str[i]);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( str[i] == <span class="string">')'</span>)&#123;</div><div class="line">                <span class="keyword">for</span>(var j = i + 1 ; stack.peek() != <span class="string">"("</span> ; j--)&#123;  //符号判断完不进行入栈操作，而是进行弹出运算</div><div class="line">                    var a1 = parseFloat(outStack.pop());</div><div class="line">                    var a2 = parseFloat(outStack.pop());</div><div class="line">                    var a3 = stack.pop();</div><div class="line">                    switch(a3)&#123;</div><div class="line">                        <span class="keyword">case</span><span class="string">'+'</span>:outStack.push(a2 + a1);</div><div class="line">                        <span class="built_in">break</span>;</div><div class="line">                        <span class="keyword">case</span><span class="string">'-'</span>:outStack.push(a2 - a1);</div><div class="line">                        <span class="built_in">break</span>;</div><div class="line">                        <span class="keyword">case</span><span class="string">'*'</span>:outStack.push(a2 * a1);</div><div class="line">                        <span class="built_in">break</span>;</div><div class="line">                        <span class="keyword">case</span><span class="string">'/'</span>:outStack.push(a2 / a1);</div><div class="line">                        <span class="built_in">break</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                stack.pop();                     </div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                var relationship = Sign(txt,str[i]);</div><div class="line">                <span class="keyword">if</span>( relationship == -1)&#123;</div><div class="line">                    stack.push(str[i]);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(relationship &gt;= 0)&#123;</div><div class="line">                    <span class="keyword">do</span>&#123;</div><div class="line">                        var b1 = parseFloat(outStack.pop());</div><div class="line">                        var b2 = parseFloat(outStack.pop());</div><div class="line">                        var a3 = stack.pop();</div><div class="line">                        switch(a3)&#123;</div><div class="line">                            <span class="keyword">case</span><span class="string">'+'</span>:outStack.push(b2 + b1);</div><div class="line">                            <span class="built_in">break</span>;</div><div class="line">                            <span class="keyword">case</span><span class="string">'-'</span>:outStack.push(b2 - b1);</div><div class="line">                            <span class="built_in">break</span>;</div><div class="line">                            <span class="keyword">case</span><span class="string">'*'</span>:outStack.push(b2 * b1);</div><div class="line">                            <span class="built_in">break</span>;</div><div class="line">                            <span class="keyword">case</span><span class="string">'/'</span>:outStack.push(b2 / b1);</div><div class="line">                            <span class="built_in">break</span>;</div><div class="line">                        &#125;</div><div class="line">                    &#125;<span class="keyword">while</span>(Sign(stack.peek(),str[i])&gt;0);</div><div class="line">                    stack.push(str[i]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    console.log(outStack.pop().toFixed(5));   //将小数位数控制在5位小数，结束运算。</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>本代码可以自行尝试输出和输入，根据这个原理以及少许html和CSS的基础就能够写出相当不错的计算器，计算器的实现也会在下次进行贴出，我还会继续分享自己的所学，点波关注不迷路，谢谢！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习了栈结构，你以为学完了栈？今天要讲的是中缀表达式转后缀表达式，后缀表达式的计算和中缀表达式的计算，接下来让我们开始吧！&lt;/p&gt;
&lt;h2 id=&quot;什么是中缀表达式和后缀表达式？&quot;&gt;&lt;a href=&quot;#什么是中缀表达式和后缀表达式？&quot; class=&quot;headerlink&quot; 
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.godlikemeteor.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.godlikemeteor.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 栈</title>
    <link href="http://www.godlikemeteor.com/2017/07/16/JavaScript%20%E6%A0%88/"/>
    <id>http://www.godlikemeteor.com/2017/07/16/JavaScript 栈/</id>
    <published>2017-07-16T11:48:02.000Z</published>
    <updated>2017-07-16T12:11:07.277Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是栈"><a href="#什么是栈" class="headerlink" title="什么是栈"></a>什么是栈</h2><p>堆栈（英语：stack），也可直接称栈（港澳台作堆叠），在计算机科学中，是一种特殊的串列形式的数据结构，它的特殊之处在于只能允许在链接串列或阵列的一端（称为堆叠顶端指标，英语：top）进行加入数据（英语：push）和输出数据（英语：pop）的运算。另外栈也可以用一维数组或连结串列的形式来完成。堆叠的另外一个相对的操作方式称为伫列。</p>
<p>由于堆叠数据结构只允许在一端进行操作，因而按照后进先出（LIFO, Last In First Out）的原理运作。</p>
<p>堆叠数据结构使用两种基本操作：推入（push）和弹出（pop）：<br>推入：将数据放入堆叠的顶端（阵列形式或串列形式），堆叠顶端top指标加一。<br>弹出：将顶端数据资料输出（回传），堆叠顶端资料减一。</p>
<h2 id="用JavaScript实现栈的数据结构"><a href="#用JavaScript实现栈的数据结构" class="headerlink" title="用JavaScript实现栈的数据结构"></a>用JavaScript实现栈的数据结构</h2><p>接下来我们就要使用JavaScript实现栈的数据结构，包含数据的推入和推出。</p>
<p>首先我们定义一个栈</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">Stack</span></span>()&#123;</div><div class="line">    this.data = [];</div><div class="line">    this.top = 0;            //记录栈顶位置</div><div class="line">    this.pop = pop;          //右推出</div><div class="line">    this.push = push;        //右进入</div><div class="line">    this.display = display;</div><div class="line">    this.length = length;    //计算数组长度</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意，top是用来记录栈顶位置，初始化为0，我们使用 <code>push()</code> 函数和 <code>pop()</code>函数来实现。</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> push(element)&#123;</div><div class="line">    this.data[this.top] = element;</div><div class="line">    this.top++;</div><div class="line">&#125;</div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">pop</span></span>()&#123;</div><div class="line">    var lastElement = this.data[this.top-1];</div><div class="line">    this.top--;</div><div class="line">    <span class="built_in">return</span> lastElement;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而<code>length()</code>函数和<code>display()</code>函数是用来显示栈长度和显示栈内元素的，下面展示函数的实现。</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">length</span></span>()&#123;</div><div class="line">    <span class="built_in">return</span> this.top;</div><div class="line">&#125;</div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">display</span></span>()&#123;</div><div class="line">    var length = this.top;</div><div class="line">    <span class="keyword">for</span>(var i=0;i&lt;length;i++)&#123;</div><div class="line">        console.log(this.data[i]);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>今天讲的东西都十分基础，是为了接下来中缀表达式和后缀表达式实现打下基础，接下来的一篇博客中将详解中缀表达式的计算过程。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是栈&quot;&gt;&lt;a href=&quot;#什么是栈&quot; class=&quot;headerlink&quot; title=&quot;什么是栈&quot;&gt;&lt;/a&gt;什么是栈&lt;/h2&gt;&lt;p&gt;堆栈（英语：stack），也可直接称栈（港澳台作堆叠），在计算机科学中，是一种特殊的串列形式的数据结构，它的特殊之处在于只能
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.godlikemeteor.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.godlikemeteor.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 循环链表 【约瑟夫斯问题】</title>
    <link href="http://www.godlikemeteor.com/2017/07/15/JavaScript%20%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/"/>
    <id>http://www.godlikemeteor.com/2017/07/15/JavaScript 循环链表/</id>
    <published>2017-07-15T10:04:09.000Z</published>
    <updated>2017-07-15T11:14:57.350Z</updated>
    
    <content type="html"><![CDATA[<p>单向链表和双向链表学完之后，就学到了循环链表，循环链表其实比双向链表简单一点，就是将单向链表的表头和尾指针连接起来，因为跟单向链表很像，在这里我将通过一个小游戏讲解循环链表。</p>
<h3 id="约瑟夫斯问题"><a href="#约瑟夫斯问题" class="headerlink" title="约瑟夫斯问题"></a>约瑟夫斯问题</h3><p>约瑟夫斯问题（有时也称为约瑟夫斯置换），是一个出现在计算机科学和数学中的问题。在计算机编程的算法中，类似问题又称为约瑟夫环。</p>
<p>有n个囚犯站成一个圆圈，准备处决。首先从一个人开始，越过k-2个人（因为第一个人已经被越过），并杀掉第k个人。接着，再越过k-1个人，并杀掉第k个人。这个过程沿着圆圈一直进行，直到最终只剩下一个人留下，这个人就可以继续活着。<br>问题是，给定了n和k，一开始要站在什么地方才能避免被处决？</p>
<p>经过改版，本游戏是通过输入总人数和杀人循环权来计算出一个循环链表中的最后一个节点，也就是最后一个幸存者的位置。</p>
<h3 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h3><p>节点的数据结构实现</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> Node(element)&#123;</div><div class="line">    this.element = element;</div><div class="line">    this.next = null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>循环链表的实现</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">LList</span></span>()&#123;</div><div class="line">    this.head = new Node(<span class="string">"head"</span>);</div><div class="line">    this.head.next = this.head; //循环链表的实现</div><div class="line">    this.find = find;</div><div class="line">    this.insert = insert;</div><div class="line">    this.display = display;</div><div class="line">    this.findPrevious =findPrevious;</div><div class="line">    this.remove = remove;</div><div class="line">    this.findLast = findLast;</div><div class="line">    this.nodegame = nodegame;</div><div class="line">    this.kill = <span class="built_in">kill</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实现链表的删除功能</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> findPrevious(item)&#123;</div><div class="line">    var currNode = this.head;</div><div class="line">    <span class="keyword">while</span>(!(currNode.next==null)&amp;&amp;(currNode.next.element != item))&#123;</div><div class="line">        currNode = currNode.next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> currNode;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">function</span> remove(item)&#123;</div><div class="line">    var prevNode = this.findPrevious(item);</div><div class="line">    <span class="keyword">if</span>(!(prevNode.next==null))&#123;</div><div class="line">        curtNode = prevNode.next;</div><div class="line">        prevNode.next = prevNode.next.next;</div><div class="line">        curtNode = null;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>链表的显示功能</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">display</span></span>()&#123;</div><div class="line">    var currNode = this.head;</div><div class="line">    <span class="keyword">while</span>(!(currNode == null) &amp;&amp; !(currNode.next.element == <span class="string">'head'</span>))&#123;</div><div class="line">        console.log(currNode.next.element);</div><div class="line">        currNode =currNode.next;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>节点的查找</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> find(item)&#123;</div><div class="line">    var currNode = this.head;</div><div class="line">    <span class="keyword">while</span>(currNode.element!=item)&#123;</div><div class="line">        currNode =currNode.next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> currNode;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> insert(newElement,item)&#123;</div><div class="line">    var newNode = new Node(newElement);</div><div class="line">    var current = this.find(item); </div><div class="line">    newNode.next = current.next;</div><div class="line">    current.next = newNode;</div><div class="line">    var lastNode = this.findLast();  </div><div class="line">        lastNode.next = this.head;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>杀人游戏的实现</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> nodegame(n,x)&#123;</div><div class="line">    var nNode = this.findLast();</div><div class="line">    <span class="keyword">for</span>(var i=1;i&lt;=n;i++)&#123;</div><div class="line">        this.insert(i,nNode.element);</div><div class="line">        nNode=nNode.next;</div><div class="line">    &#125;</div><div class="line">    this.kill(n,x);</div><div class="line">    var result = this.findLast().element;</div><div class="line">    this.head.next = this.head;</div><div class="line">    <span class="built_in">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="keyword">function</span> <span class="built_in">kill</span>(num,n)&#123;</div><div class="line">    var count=num-1;</div><div class="line">    var currNode = this.head;</div><div class="line">    <span class="keyword">while</span>(count)&#123;</div><div class="line">        <span class="keyword">for</span>(var i=0;i&lt;n;i++)&#123;</div><div class="line">            currNode=currNode.next;</div><div class="line">            <span class="keyword">if</span>(currNode==this.head)currNode=currNode.next;</div><div class="line">        &#125;</div><div class="line">        this.remove(currNode.element);</div><div class="line">        count--;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">var gal = new LList();</div><div class="line"><span class="keyword">function</span> game(playerNum,killNum)&#123;</div><div class="line">    <span class="built_in">return</span> gal.nodegame(playerNum,killNum);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>特别感谢大佬，喜欢的戳这里→<a href="https://github.com/sokonen" target="_blank" rel="external">大佬</a>,今天的代码就分享到这里。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单向链表和双向链表学完之后，就学到了循环链表，循环链表其实比双向链表简单一点，就是将单向链表的表头和尾指针连接起来，因为跟单向链表很像，在这里我将通过一个小游戏讲解循环链表。&lt;/p&gt;
&lt;h3 id=&quot;约瑟夫斯问题&quot;&gt;&lt;a href=&quot;#约瑟夫斯问题&quot; class=&quot;head
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.godlikemeteor.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.godlikemeteor.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 双向链表</title>
    <link href="http://www.godlikemeteor.com/2017/07/15/JavaScript%20%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <id>http://www.godlikemeteor.com/2017/07/15/JavaScript 双向链表/</id>
    <published>2017-07-15T08:46:29.000Z</published>
    <updated>2017-07-15T08:46:11.691Z</updated>
    
    <content type="html"><![CDATA[<p>经过上次的单向链表的讲解，大家可能对链表这种数据结构有了一定的理解，今天要讲的是有关JavaScript双向链表的基本介绍。<br>有关单向链表的基础知识请参考我的博客<a href="http://godlikemeteor.com/2017/07/11/JavaScript%20%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/" target="_blank" rel="external">JavaScript 单向链表</a></p>
<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><h3 id="新建一个链表"><a href="#新建一个链表" class="headerlink" title="新建一个链表"></a>新建一个链表</h3><p>双向链表跟单向链表的节点结构不同之处就是双向链表有一个前驱，这就需要我们构建一个指向前一个节点的指针。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> Node(element)&#123;</div><div class="line">    this.element = element;</div><div class="line">    this.next = null;</div><div class="line">    this.previous = null</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来就如单向链表一样创建一个链表。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">LList</span></span>()&#123;</div><div class="line">    this.head = new Node(<span class="string">"head"</span>);       //建立链表的头节点</div><div class="line">    this.find = find;                   //查找指定节点</div><div class="line">    this.insert = insert;               //插入节点</div><div class="line">    this.display = display;             //显示所有节点</div><div class="line">    this.findLast = findLast;           //查找最后一个节点</div><div class="line">    this.remove = remove;               //删除指定节点</div><div class="line">    this.disReverse = disReverse;       //链表的反序排列</div><div class="line">    this.findPrevious = findPrevious;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此，一个链表的基本结构就建好了，接下来我们需要通过一系列的功能测试这个链表。</p>
<h3 id="实现链表的查找功能"><a href="#实现链表的查找功能" class="headerlink" title="实现链表的查找功能"></a>实现链表的查找功能</h3><p>就如单向链表一样，需要我们调用链表的查找函数 find()。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> find(item)&#123;</div><div class="line">    var findNode = this.head;           </div><div class="line">    <span class="keyword">while</span>(findNode.element!=item)&#123;      </div><div class="line">        findNode = findNode.next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> findNode;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>查找函数的参数就是链表的内容，即element。</p>
<h3 id="实现链表的插入功能"><a href="#实现链表的插入功能" class="headerlink" title="实现链表的插入功能"></a>实现链表的插入功能</h3><p>查找的目的不仅仅是创建一个链表，你也可以通过查找函数确定链表内数据是否正确，接下来需要实现的就是我们的插入函数 insert() 了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> insert(newElement,item)&#123;</div><div class="line">    var newNode = new Node(newElement); //创建一个新的节点</div><div class="line">    var beforeNode = this.find(item);   //寻找想插入的前一个元素</div><div class="line">    <span class="keyword">if</span>(beforeNode.next!=null)&#123;</div><div class="line">        newNode.next = beforeNode.next;     //新创建节点的指针复制</div><div class="line">        beforeNode.next.previous = newNode; //将新创建节点下一个节点指向新创建的节点</div><div class="line">        beforeNode.next = newNode;          //将前一个节点的指针指向新创建的节点</div><div class="line">        newNode.previous = beforeNode;      //将新建节点的前驱指向上一个节点</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        newNode.next = beforeNode.next;     //新创建节点的指针复制</div><div class="line">        beforeNode.next = newNode;          //将前一个节点的指针指向新创建的节点</div><div class="line">        newNode.previous = beforeNode;      //将新建节点的前驱指向上一个节点</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>newElement是你想要插入节点的内容，而item是你想要插入节点的前一个节点的内容。</p>
<h3 id="实现链表的显示功能"><a href="#实现链表的显示功能" class="headerlink" title="实现链表的显示功能"></a>实现链表的显示功能</h3><p>通过查找前一个节点，就可以实现在指定节点后插入节点的操作了。接下来检验我们的函数是否可用，就需要调用我们的显示函数 display() 了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">display</span></span>()&#123;</div><div class="line">    var findNode = this.head;            </div><div class="line">    <span class="keyword">while</span>(!(findNode.next == null))&#123;     </div><div class="line">        console.log(findNode.next.element);</div><div class="line">        findNode = findNode.next;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>display() 需要在Google console 中调用，通过调用你会发现建立了一个完整的链表结构，而且可以随心所欲的更改链表的数据了。</p>
<h3 id="实现链表的删除功能"><a href="#实现链表的删除功能" class="headerlink" title="实现链表的删除功能"></a>实现链表的删除功能</h3><p>链表的删除功能其实就是将链表的指针指向下下个节点上，因为浏览器的缓存特性，浏览器会自动清除无用的节点，这样便实现了链表节点的删除，但在删除节点之前我们需要找到删除的节点的前一个节点，然后改变指针就可以了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> findPrevious(item)&#123;</div><div class="line">    var findNode = this.head;            </div><div class="line">    <span class="keyword">while</span>(findNode.next.element!=item)&#123;  </div><div class="line">        findNode =findNode.next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> findNode;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>找到前一个节点，就可以实现我们的删除操作了，删除需要 remove() 函数实现。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> remove(item)&#123;</div><div class="line">    var findNode = this.findPrevious(item);//找到删除节点的前一个节点</div><div class="line">    <span class="keyword">if</span>(findNode.next.next!=null)&#123;</div><div class="line">        findNode.next = findNode.next.next;    //将删除节点之后的节点向前移位</div><div class="line">        findNode.next.next.previous = findNode;//将删除节点的前指针指向删除节点的前一个节点，浏览器自动清除无用的节点</div><div class="line">    &#125;      </div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        findNode.next = findNode.next.next;    //将删除节点之后的节点向前移位</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来我们可以使用 display() 函数调用，就可以发现已经可以实现功能了。</p>
<h3 id="实现链表的反序排序功能"><a href="#实现链表的反序排序功能" class="headerlink" title="实现链表的反序排序功能"></a>实现链表的反序排序功能</h3><p>双向链表区别于单向链表最重要的功能就是反向排序，反向排序需要我们找到最后一个节点，然后通过前驱依次遍历，首先我们需要 findLast() 实现查找最后一个节点。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">findLast</span></span>()&#123;</div><div class="line">    var findNode = this.head;            //找到表头</div><div class="line">    <span class="keyword">while</span>(!(findNode.next == null))&#123;     //查找是否节点的后驱指针为空</div><div class="line">        findNode = findNode.next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> findNode;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后直接调用排序函数就可以实现链表的反向排序输出了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">disReverse</span></span>()&#123;</div><div class="line">    var findNode = this.head;</div><div class="line">    findNode = this.findLast();</div><div class="line">    <span class="keyword">while</span>(!(findNode.previous == null))&#123;</div><div class="line">        console.log(findNode.element);</div><div class="line">        findNode = findNode.previous;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过这次讲解是不是对链表这种数据结构产生了兴趣？接下来还会推出有关循环链表的博客，也会给大家讲一个小游戏，敬请期待！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;经过上次的单向链表的讲解，大家可能对链表这种数据结构有了一定的理解，今天要讲的是有关JavaScript双向链表的基本介绍。&lt;br&gt;有关单向链表的基础知识请参考我的博客&lt;a href=&quot;http://godlikemeteor.com/2017/07/11/JavaScri
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.godlikemeteor.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://www.godlikemeteor.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>你不得不知道的Git命令</title>
    <link href="http://www.godlikemeteor.com/2017/07/12/%E4%BD%A0%E4%B8%8D%E5%BE%97%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Git%E5%91%BD%E4%BB%A4/"/>
    <id>http://www.godlikemeteor.com/2017/07/12/你不得不知道的Git命令/</id>
    <published>2017-07-12T04:17:28.000Z</published>
    <updated>2017-07-12T06:58:35.960Z</updated>
    
    <content type="html"><![CDATA[<p>GitHub是一个通过Git进行版本控制的软件源代码托管服务，由GitHub公司（曾称Logical Awesome）的开发者Chris Wanstrath、PJ Hyett和Tom Preston-Werner使用Ruby on Rails编写而成。</p>
<p>GitHub同时提供付费账户和免费账户。这两种账户都可以创建公开的代码仓库，但是付费账户还可以创建私有的代码仓库。根据在2009年的Git用户调查，GitHub是最流行的Git访问站点。除了允许个人和组织创建和访问保管中的代码以外，它也提供了一些方便社会化共同软件开发的功能，即一般人口中的社区功能，包括允许用户追踪其他用户、组织、软件库的动态，对软件代码的改动和bug提出评论等。GitHub也提供了图表功能，用于概观显示开发者们怎样在代码库上工作以及软件的开发活跃程度。</p>
<p>经过几天的博客搭建，终于搭好了自己的博客，在这个过程中我也发现有一些Git指令不是特别会写，所以查阅了很多资料，总结在这里，也作为一些参考。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line">git init                                                  <span class="comment"># 初始化本地git仓库（创建新仓库）</span></div><div class="line">git config --global user.name <span class="string">"xxx"</span>                       <span class="comment"># 配置用户名</span></div><div class="line">git config --global user.email <span class="string">"xxx@xxx.com"</span>              <span class="comment"># 配置邮件</span></div><div class="line">git config --global color.ui <span class="literal">true</span>                         <span class="comment"># git status等命令自动着色</span></div><div class="line">git config --global color.status auto</div><div class="line">git config --global color.diff auto</div><div class="line">git config --global color.branch auto</div><div class="line">git config --global color.interactive auto</div><div class="line">git config --global --<span class="built_in">unset</span> http.proxy                    <span class="comment"># remove  proxy configuration on git</span></div><div class="line">git <span class="built_in">clone</span> git+ssh://git@192.168.53.168/VT.git             <span class="comment"># clone远程仓库</span></div><div class="line">git status                                                <span class="comment"># 查看当前版本状态（是否修改）</span></div><div class="line">git add xyz                                               <span class="comment"># 添加xyz文件至index</span></div><div class="line">git add .                                                 <span class="comment"># 增加当前子目录下所有更改过的文件至index</span></div><div class="line">git commit -m <span class="string">'xxx'</span>                                       <span class="comment"># 提交</span></div><div class="line">git commit --amend -m <span class="string">'xxx'</span>                               <span class="comment"># 合并上一次提交（用于反复修改）</span></div><div class="line">git commit -am <span class="string">'xxx'</span>                                      <span class="comment"># 将add和commit合为一步</span></div><div class="line">git rm xxx                                                <span class="comment"># 删除index中的文件</span></div><div class="line">git rm -r *                                               <span class="comment"># 递归删除</span></div><div class="line">git <span class="built_in">log</span>                                                   <span class="comment"># 显示提交日志</span></div><div class="line">git <span class="built_in">log</span> -1                                                <span class="comment"># 显示1行日志 -n为n行</span></div><div class="line">git <span class="built_in">log</span> -5</div><div class="line">git <span class="built_in">log</span> --<span class="built_in">stat</span>                                            <span class="comment"># 显示提交日志及相关变动文件</span></div><div class="line">git <span class="built_in">log</span> -p -m</div><div class="line">git show dfb02e6e4f2f7b573337763e5c0013802e392818         <span class="comment"># 显示某个提交的详细内容</span></div><div class="line">git show dfb02                                            <span class="comment"># 可只用commitid的前几位</span></div><div class="line">git show HEAD                                             <span class="comment"># 显示HEAD提交日志</span></div><div class="line">git show HEAD^                                            <span class="comment"># 显示HEAD的父（上一个版本）的提交日志 ^^为上两个版本 ^5为上5个版本</span></div><div class="line">git tag                                                   <span class="comment"># 显示已存在的tag</span></div><div class="line">git tag -a v2.0 -m <span class="string">'xxx'</span>                                  <span class="comment"># 增加v2.0的tag</span></div><div class="line">git show v2.0                                             <span class="comment"># 显示v2.0的日志及详细内容</span></div><div class="line">git <span class="built_in">log</span> v2.0                                              <span class="comment"># 显示v2.0的日志</span></div><div class="line">git diff                                                  <span class="comment"># 显示所有未添加至index的变更</span></div><div class="line">git diff --cached                                         <span class="comment"># 显示所有已添加index但还未commit的变更</span></div><div class="line">git diff HEAD^                                            <span class="comment"># 比较与上一个版本的差异</span></div><div class="line">git diff HEAD -- ./lib                                    <span class="comment"># 比较与HEAD版本lib目录的差异</span></div><div class="line">git diff origin/master..master                            <span class="comment"># 比较远程分支master上有本地分支master上没有的</span></div><div class="line">git diff origin/master..master --<span class="built_in">stat</span>                     <span class="comment"># 只显示差异的文件，不显示具体内容</span></div><div class="line">git remote add origin git+ssh://git@192.168.53.168/VT.git <span class="comment"># 增加远程定义（用于push/pull/fetch）</span></div><div class="line">git branch                                                <span class="comment"># 显示本地分支</span></div><div class="line">git branch --contains 50089                               <span class="comment"># 显示包含提交50089的分支</span></div><div class="line">git branch -a                                             <span class="comment"># 显示所有分支</span></div><div class="line">git branch -r                                             <span class="comment"># 显示所有原创分支</span></div><div class="line">git branch --merged                                       <span class="comment"># 显示所有已合并到当前分支的分支</span></div><div class="line">git branch --no-merged                                    <span class="comment"># 显示所有未合并到当前分支的分支</span></div><div class="line">git branch -m master master_copy                          <span class="comment"># 本地分支改名</span></div><div class="line">git checkout -b master_copy                               <span class="comment"># 从当前分支创建新分支master_copy并检出</span></div><div class="line">git checkout -b master master_copy                        <span class="comment"># 上面的完整版</span></div><div class="line">git checkout features/performance                         <span class="comment"># 检出已存在的features/performance分支</span></div><div class="line">git checkout --track hotfixes/BJVEP933                    <span class="comment"># 检出远程分支hotfixes/BJVEP933并创建本地跟踪分支</span></div><div class="line">git checkout v2.0                                         <span class="comment"># 检出版本v2.0</span></div><div class="line">git checkout -b devel origin/develop                      <span class="comment"># 从远程分支develop创建新本地分支devel并检出</span></div><div class="line">git checkout -- README                                    <span class="comment"># 检出head版本的README文件（可用于修改错误回退）</span></div><div class="line">git merge origin/master                                   <span class="comment"># 合并远程master分支至当前分支</span></div><div class="line">git cherry-pick ff44785404a8e                             <span class="comment"># 合并提交ff44785404a8e的修改</span></div><div class="line">git push origin master                                    <span class="comment"># 将当前分支push到远程master分支</span></div><div class="line">git push origin :hotfixes/BJVEP933                        <span class="comment"># 删除远程仓库的hotfixes/BJVEP933分支</span></div><div class="line">git push --tags                                           <span class="comment"># 把所有tag推送到远程仓库</span></div><div class="line">git fetch                                                 <span class="comment"># 获取所有远程分支（不更新本地分支，另需merge）</span></div><div class="line">git fetch --prune                                         <span class="comment"># 获取所有原创分支并清除服务器上已删掉的分支</span></div><div class="line">git pull origin master                                    <span class="comment"># 获取远程分支master并merge到当前分支</span></div><div class="line">git mv README README2                                     <span class="comment"># 重命名文件README为README2</span></div><div class="line">git reset --hard HEAD                                     <span class="comment"># 将当前版本重置为HEAD（通常用于merge失败回退）</span></div><div class="line">git rebase</div><div class="line">git branch -d hotfixes/BJVEP933                           <span class="comment"># 删除分支hotfixes/BJVEP933（本分支修改已合并到其他分支）</span></div><div class="line">git branch -D hotfixes/BJVEP933                           <span class="comment"># 强制删除分支hotfixes/BJVEP933</span></div><div class="line">git ls-files                                              <span class="comment"># 列出git index包含的文件</span></div><div class="line">git show-branch                                           <span class="comment"># 图示当前分支历史</span></div><div class="line">git show-branch --all                                     <span class="comment"># 图示所有分支历史</span></div><div class="line">git whatchanged                                           <span class="comment"># 显示提交历史对应的文件修改</span></div><div class="line">git revert dfb02e6e4f2f7b573337763e5c0013802e392818       <span class="comment"># 撤销提交dfb02e6e4f2f7b573337763e5c0013802e392818</span></div><div class="line">git ls-tree HEAD                                          <span class="comment"># 内部命令：显示某个git对象</span></div><div class="line">git rev-parse v2.0                                        <span class="comment"># 内部命令：显示某个ref对于的SHA1 HASH</span></div><div class="line">git reflog                                                <span class="comment"># 显示所有提交，包括孤立节点</span></div><div class="line">git show HEAD@&#123;5&#125;</div><div class="line">git show master@&#123;yesterday&#125;                               <span class="comment"># 显示master分支昨天的状态</span></div><div class="line">git <span class="built_in">log</span> --pretty=format:<span class="string">'%h %s'</span> --graph                   <span class="comment"># 图示提交日志</span></div><div class="line">git show HEAD~3</div><div class="line">git show -s --pretty=raw 2be7fcb476</div><div class="line">git stash                                                 <span class="comment"># 暂存当前修改，将所有至为HEAD状态</span></div><div class="line">git stash list                                            <span class="comment"># 查看所有暂存</span></div><div class="line">git stash show -p stash@&#123;0&#125;                               <span class="comment"># 参考第一次暂存</span></div><div class="line">git stash apply stash@&#123;0&#125;                                 <span class="comment"># 应用第一次暂存</span></div><div class="line">git grep <span class="string">"delete from"</span>                                    <span class="comment"># 文件中搜索文本“delete from”</span></div><div class="line">git grep -e <span class="string">'#define'</span> --and -e SORT_DIRENT</div><div class="line">git gc</div><div class="line">git fsck</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GitHub是一个通过Git进行版本控制的软件源代码托管服务，由GitHub公司（曾称Logical Awesome）的开发者Chris Wanstrath、PJ Hyett和Tom Preston-Werner使用Ruby on Rails编写而成。&lt;/p&gt;
&lt;p&gt;Git
    
    </summary>
    
      <category term="搭建博客" scheme="http://www.godlikemeteor.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="github" scheme="http://www.godlikemeteor.com/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 单向链表</title>
    <link href="http://www.godlikemeteor.com/2017/07/11/JavaScript%20%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    <id>http://www.godlikemeteor.com/2017/07/11/JavaScript 单向链表/</id>
    <published>2017-07-10T23:32:29.000Z</published>
    <updated>2017-07-11T10:58:25.062Z</updated>
    
    <content type="html"><![CDATA[<p>欢迎大家来到我的博客，这是我的第一篇技术性博客，今天给大家讲解有关于JavaScript单向链表的建立和操作过程，希望大家能够从中收获到知识，我也会定期更新自己所学的知识到这个博客上。</p>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="新建一个链表"><a href="#新建一个链表" class="headerlink" title="新建一个链表"></a>新建一个链表</h3><p>链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。链表中最简单的一种是单向链表，它包含两个域，一个信息域和一个指针域。JavaScript中的单向链表也是如此，建立一个链表我们首先先要建立一个最基础的属性：节点</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> Node(element)&#123;</div><div class="line">    this.element = element;</div><div class="line">    this.next = null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为JavaScript是一种弱类型的语言，所以使用函数定义节点，而next即为节点的指针，接下来就要创建我们的链表了，但是光有链表还不够，还需要一些链表的操作，添加节点的查找、插入、显示和删除四个功能。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">LList</span></span>()&#123;</div><div class="line">    this.head = new Node(<span class="string">"head"</span>);       </div><div class="line">    this.find = find;                   </div><div class="line">    this.insert = insert;               </div><div class="line">    this.display = display;             </div><div class="line">    this.findPrevious = findPrevious;   </div><div class="line">    this.remove = remove;               </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此，一个链表的基本结构就建好了，接下来我们需要通过一系列的功能测试这个链表</p>
<h3 id="实现链表的查找功能"><a href="#实现链表的查找功能" class="headerlink" title="实现链表的查找功能"></a>实现链表的查找功能</h3><p>尽管已经建立出一个链表，但是因为这个链表只包含一个头节点，所以我们要插入自己想要的数据，但是如何确定插入元素在什么位置上呢？这就需要我们调用链表的查找函数 find() 了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> find(item)&#123;</div><div class="line">    var findNode = this.head;           </div><div class="line">    <span class="keyword">while</span>(findNode.element!=item)&#123;      </div><div class="line">        findNode = findNode.next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> findNode;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>查找函数的参数就是链表的内容，即element。</p>
<h3 id="实现链表的插入功能"><a href="#实现链表的插入功能" class="headerlink" title="实现链表的插入功能"></a>实现链表的插入功能</h3><p>查找的目的不仅仅是创建一个链表，你也可以通过查找函数确定链表内数据是否正确，接下来需要实现的就是我们的插入函数 insert() 了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> insert(newElement,item)&#123;</div><div class="line">    var newNode = new Node(newElement);  </div><div class="line">    var beforeNode = this.find(item);    </div><div class="line">    newNode.next = beforeNode.next;      </div><div class="line">    beforeNode.next = newNode;           </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>newElement是你想要插入节点的内容，而item是你想要插入节点的前一个节点的内容。</p>
<h3 id="实现链表的显示功能"><a href="#实现链表的显示功能" class="headerlink" title="实现链表的显示功能"></a>实现链表的显示功能</h3><p>通过查找前一个节点，就可以实现在指定节点后插入节点的操作了。接下来检验我们的函数是否可用，就需要调用我们的显示函数 display() 了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">display</span></span>()&#123;</div><div class="line">    var findNode = this.head;            </div><div class="line">    <span class="keyword">while</span>(!(findNode.next == null))&#123;     </div><div class="line">        console.log(findNode.next.element);</div><div class="line">        findNode = findNode.next;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>display() 需要在Google console 中调用，通过调用你会发现建立了一个完整的链表结构，而且可以随心所欲的更改链表的数据了。</p>
<h3 id="实现链表的删除功能"><a href="#实现链表的删除功能" class="headerlink" title="实现链表的删除功能"></a>实现链表的删除功能</h3><p>链表的删除功能其实就是将链表的指针指向下下个节点上，因为浏览器的缓存特性，浏览器会自动清除无用的节点，这样便实现了链表节点的删除，但在删除节点之前我们需要找到删除的节点的前一个节点，然后改变指针就可以了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> findPrevious(item)&#123;</div><div class="line">    var findNode = this.head;            </div><div class="line">    <span class="keyword">while</span>(findNode.next.element!=item)&#123;  </div><div class="line">        findNode =findNode.next;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> findNode;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>找到前一个节点，就可以实现我们的删除操作了，删除需要 remove() 函数实现。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> remove(item)&#123;</div><div class="line">    var findNode = this.findPrevious(item);  </div><div class="line">    findNode.next = findNode.next.next;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来我们可以使用 display() 函数调用，就可以发现已经可以实现功能了，这是最基本的链表操作，接下来还会推出有关双向链表等博客，谢谢大家支持！</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;欢迎大家来到我的博客，这是我的第一篇技术性博客，今天给大家讲解有关于JavaScript单向链表的建立和操作过程，希望大家能够从中收获到知识，我也会定期更新自己所学的知识到这个博客上。&lt;/p&gt;
&lt;h2 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerl
    
    </summary>
    
      <category term="JavaScript" scheme="http://www.godlikemeteor.com/categories/JavaScript/"/>
    
    
      <category term="github" scheme="http://www.godlikemeteor.com/tags/github/"/>
    
      <category term="JavaScript" scheme="http://www.godlikemeteor.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>人生若只如初见</title>
    <link href="http://www.godlikemeteor.com/2017/07/09/%E4%BA%BA%E7%94%9F%E8%8B%A5%E5%8F%AA%E5%A6%82%E5%88%9D%E8%A7%81/"/>
    <id>http://www.godlikemeteor.com/2017/07/09/人生若只如初见/</id>
    <published>2017-07-09T06:24:51.000Z</published>
    <updated>2017-07-10T11:52:05.464Z</updated>
    
    <content type="html"><![CDATA[<p>“人生若只如初见”，清代词人纳兰性德的这句诗词几乎无人不念，无人不爱，这句诗词无论在哪里出现，哪里游走，它都是那么的入心入眼，带给人无限绕指柔的情愫。毋庸置疑，“人生若只如初见”这飘渺出尘的七个字一定是惊艳了无数人的时光，也温柔了无数人的岁月。</p>
<p>红尘太多美丽的初见，宛若人间四月天，它不仅有花开的嫣然，也有花香的萦绕；它不仅有诗情的浮动，也有诗意的摇曳。只是，如果人生只如初见，那么人间也就不会有《钗头凤》的千年绝唱；如果人生只如初见，那么世上也就不会有梁祝化蝶飞的千古传奇；如果人生只如初见，那么凡尘也就不会有雷峰塔的千年喟叹。</p>
<p>行走在光阴里的人，谁不对初见怀揣一份美好向往和期待？谁不对初见心存一份眷恋和不舍？假如人生是一场途经，初见一定是人生路上最美的绽放。人生在世，不管你是青丝如云，还是白发如霜，当你念及“人生若只如初见”时，你的嘴角一定会不由自主地泛起一抹淡淡的笑意，你的内心一定会情不自禁地漾开一弯涟漪。</p>
<p>一次萍聚，让多少午夜梦回，衣袖盈香？一次邂逅，让多少暗香浮动，刹那芳华？一份爱情，从开始到结束，初见，永远是最美丽的风景；一个故事，从上演到谢幕，初见，永远是最难忘的情节。初见，它可以是朦胧到极致，又可以是清晰到极致的画面；初见，它可以是淡雅到极致，又可以浓烈到极致的情愫。人生来去，虽然初见只是惊鸿一瞥，昙花一现，但它总是让人朝思暮想，念念不忘。</p>
<p>从古至今，人生遗憾的事，莫过于故事还未开始就已结束；人生痛苦的事，莫过于故事未完主角就已匆匆离场；人生悲哀的事，莫过于故事还在继续悲剧就已注定。缘来缘去，若一切如初见那该有多美妙、多幸福，若相看两不厌那该有多难得、多可贵。</p>
<p>岁月的经筒不停地摇转，假如世人能在懂得里皈依，那么，无论在叶落花谢的日子，还是在丰盈晴好的时光，人与人遇见时心里就能轻言一句：“哦，原来你也在这里”，人与人分离时便能挥手轻道一声：“你若安好，便是晴天”。</p>
<p>红尘的初识里，总有许多是花开的惊喜；人间的离别里，总有许多是花落的悲哀。其实，人世间所有的爱恨痴缠都注定是彼此生命里的一程风雨、一道风景、一个故事。若是无缘，也许某些曾经便会在心灵深处印刻成遗憾和忧伤；若是有缘，一切的交集便能在流年的脉络里蜕变成旖旎和慈悲。</p>
<p>人生若只如初见，隔山隔水的守望里，三千青丝将不再有凌乱的飞扬，飘飘的衣衫上将不再有苦泪千行。人生若只如初见，纵然擦肩，也不会只成陌路；纵然转身，也不会只剩空无。人生若只如初见，美丽的风景将一直在路上，凡尘的烟火就会陪伴爱的故事走到地老天荒，途经的四季便不会在风中枯瘦。人生若只如初见，所有的相思都将美到落泪，所有的日子都将活色生香。</p>
<p>此生的来去，有人催开了十里桃花，带来了人间四月天，为平庸的生命增添了不凡和曼妙；有人覆灭了一路灯盏，带来了波折和黑暗，让平静的世界沾染了怨恨和薄情。似水流年里，不管红颜抑或白发，不管青春抑或暮年，从初遇到离别，无论恨或不恨，都是对生命过往的记载；从初见到熟识，无论爱或不爱，都是对时间留白的成全。</p>
<p>丹青为谁美，人生几壶泪？这世上，有一种珍惜永远胜过次第花开，有一种懂得永远胜过繁花似锦。烟雨红尘，每个人都是因爱而降临人间，愿只愿，有爱之人不染孤身葬花的悲凉，有情之人能有与之偕老的欢喜。愿只愿，天上人间，永远花开是画，花落成诗。</p>
<p>烟火流年，如梦翩跹。人生若只如初见，手中无花也生香，心中无声亦深情。不管生命是一场美丽之约，还是凄苦之旅，请与初心常相伴，且与真情共白首。任时光流转，永远眼中有风月，心中有诗情，守一处花开，拥一份清欢。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;“人生若只如初见”，清代词人纳兰性德的这句诗词几乎无人不念，无人不爱，这句诗词无论在哪里出现，哪里游走，它都是那么的入心入眼，带给人无限绕指柔的情愫。毋庸置疑，“人生若只如初见”这飘渺出尘的七个字一定是惊艳了无数人的时光，也温柔了无数人的岁月。&lt;/p&gt;
&lt;p&gt;红尘太多美丽的
    
    </summary>
    
      <category term="文章阅读" scheme="http://www.godlikemeteor.com/categories/%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="github" scheme="http://www.godlikemeteor.com/tags/github/"/>
    
      <category term="美文" scheme="http://www.godlikemeteor.com/tags/%E7%BE%8E%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.godlikemeteor.com/2016/11/09/hello-world/"/>
    <id>http://www.godlikemeteor.com/2016/11/09/hello-world/</id>
    <published>2016-11-08T16:00:00.000Z</published>
    <updated>2017-07-10T23:34:03.704Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
    
    </summary>
    
      <category term="搭建博客" scheme="http://www.godlikemeteor.com/categories/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="npm" scheme="http://www.godlikemeteor.com/tags/npm/"/>
    
      <category term="hexo" scheme="http://www.godlikemeteor.com/tags/hexo/"/>
    
      <category term="github" scheme="http://www.godlikemeteor.com/tags/github/"/>
    
  </entry>
  
</feed>
